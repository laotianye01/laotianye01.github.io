# ALL IN ONE



## 1.外界访问服务器

1. DDNS：可应对没有固定公网IP的情况。通过路由器的域名解析（如花生壳提供的服务）功能将互联网中的某个域名解析到自己的路由器，并通过在该主机上运行提供内DDNS服务的原件进行端口的映射

2. 内网穿透：在获取固定公网IP后，将路由器通过运营商改为桥接，并修改主路由器为PPPoE的拨号模式（如有其他则为DHCP自动获取）。在路由器中为目标设备配置通过MAC地址绑定固定的内网IP地址；并在路由器中配置端口转发，将外侧给定端口映射到内部给定端口（即提供服务的端口）

3. 域名解析：将域名与公网地址进行对应。不同服务商提供方式并不相同？阿里云是直接绑定公网IP，向日葵是获取本机公网IP再进行域名解析

4. 防火墙配置（ubuntu）

   * 参考链接：[Ubuntu ufw/firewall 防火墙规则设置](https://blog.csdn.net/u011218356/article/details/107338612)

   * ufw （自带未启用）

   * firewalld （默认启用）

   * 在配置远程服务时必须保证对应的端口与协议被允许
     ```
     // 列出所有允许的协议与端口
     sudo firewall-cmd --list-all
     
     // 查看服务状况
     systemctl status firewalld.service
     
     // 添加规则
     sudo firewall-cmd --permanent --add-port=10005/tcp
     
     // 重载与更新
     sudo firewall-cmd --reload
     ```

     



## 2.Cloudreve网盘配置



* 参考链接：
  1. [快速开始 | 简体中文 (cloudreve.org)](https://docs.cloudreve.org/getting-started/install)



* **进程守护（linux启动项设置）**
  
  ```
  sudo vim /etc/systemd/system/cloudreve.service
  
  [Unit]
  Description=Cloudreve
  Documentation=https://docs.cloudreve.org
  After=network.target
  After=mysqld.service
  Wants=network.target
  
  [Service]
  WorkingDirectory=/home/yelu/cloudreve
  ExecStart=/home/yelu/cloudreve/cloudreve -c /home/yelu/cloudreve/conf.ini
  Restart=on-abnormal
  RestartSec=5s
  KillMode=mixed
  
  StandardOutput=null
  StandardError=syslog
  
  [Install]
  WantedBy=multi-user.target
  
  
  // 相关指令# 更新配置
  sudo systemctl daemon-reload
  
  # 启动服务
  sudo systemctl start cloudreve
  
  # 设置开机启动
  sudo systemctl enable cloudreve
  管理命令：
  
  # 停止服务
  sudo systemctl stop cloudreve
  
  # 重启服务
  sudo systemctl restart cloudreve
  
  # 查看状态
  sudo systemctl status cloudreve
  ```
  
  



## 3.个人网站搭建（静态）



* 参考链接

  1. [快速入门 | Jekyll • 一个简洁的博客、静态网站生成工具](https://www.jekyll.com.cn/docs/)
  2. [如何在 Ubuntu 22.04 上安装 Jekyll 静态网站生成器 (linux-console.net)](https://cn.linux-console.net/?p=3527)
  
* jekyll项目环境搭建

  1. **Ruby** 提供了 Jekyll 和其他工具运行的基础环境，其为一种语言。
  2. **Gems** 用以安装像 Jekyll 和 Bundler 这样的gem软件包，作为Ruby项目或程序的依赖。
  3. **Bundler** 用于管理 Jekyll 项目的的 gems 版本，并且所有依赖项都被正确安装，同时为项目提供正确的运行环境 -> `bundle exec jekyll servece`。在2.X(不确定)版本之后，`jekyll`项目的版本配置与依赖通过`Gemfile`与`Gemfile.lock`两个文件进行管理。其可通过`bundle add <gem name>`，`bundle updata`与`bundle install`进行管理。在没有Gemfile时，可使用`bundle init`初始化。
  4. **Jekyll** 利用 Ruby 的功能来生成静态网站。


* jekyll创建静态网站

  ```
  // 生成静态网站项目（可按ctrl C终止）
  Jekyll new blog.com
  
  // 项目使用Gemfile进行依赖管理，在项目文件家中运行bundle install可下载Gemfile中的依赖
  bundle install
  
  // 运行项目时提示缺少依赖可使用bundle补全
  bundle add <dependency>
  
  // 使用bundle启动jekyll项目
  bundle exec jekyll server
  ```

* 使用apache代理jekyll服务（可选步骤）

  1. 下载apache2服务

     ```
     // 下载
     sudo apt install apache2
     // 起停用
     sudo service apache2 restart
     sudo service apache2 start
     sudo service apache2 stop
     // 查看状态
     sudo systemctl status apache2.service -l --no-pager
     ```

     

  2. 配置路由器端口映射，配置主机防火墙
     ```
     // 核心为将外部访问路由器某个端口的流量转发到指定的主机上
     10000 -> 10000
     
     // 将使用的协议添加到主机的防火墙
     sudo firewall-cmd --permanent --add-port=10000/tcp
     
     // 更新防火墙策略
     sudo firewall-cmd --reload
     ```
  
     
  
  3. 使apache监听虚拟机的端口
     ```
     sudo vim /etc/apache2/apache2.conf
     
     listen <vim_port>
     ```
  
     
  
  4. 在apache中添加代理站点信息
  
     ```
     // 新建配置文件
     sudo vim /etc/apache2/sites-available/jekyll.conf
     
     // 添加代理内容，此处VirtualHost的端口要与路由器的转发相同
     <VirtualHost *:10000>
         ServerName blog.com
         ServerAdmin yelu@blog.com
     
         ProxyPreserveHost On
         ProxyPass / http://localhost:4000/
         ProxyPassReverse / http://localhost:4000/
     
         ErrorLog ${APACHE_LOG_DIR}/jekyll_error.log
         CustomLog ${APACHE_LOG_DIR}/jekyll_access.log combined
     </VirtualHost>
     
     ```
  
  5. 启动代理（可选步骤）

     ```
     sudo a2enmod proxy
     sudo a2enmod proxy_http
     
     // 启动新的虚拟主机，禁用原默认虚拟主机
     sudo a2ensite jekyll.conf
     sudo a2dissite 000-default
     ```
  
  6. 启动/重启Apache服务
  
     ```
     // 首先启动jekyll服务，在启动/重启apache
     sudo systemctl restart apache2
     ```
  
  7. 配置开机启动
     ```
     // 核心为三个有关的环境变量
     [Unit]
     Description=Jekyll
     Documentation=https://jekyllcn.com/docs/home/
     After=network.target
     Wants=network.target
     
     [Service]
     WorkingDirectory=/home/yelu/blog
     Environment=GEM_PATH=/home/yelu/gems
     Environment=GEM_HOME=/home/yelu/gems
     Environment=BUNDLE_GEMFILE=/home/yelu/blog/Gemfile
     ExecStart=/home/yelu/gems/bin/bundle exec jekyll serve
     Restart=on-abnormal
     RestartSec=5s
     KillMode=mixed
     
     StandardOutput=null
     StandardError=syslog
     
     [Install]
     WantedBy=multi-user.target
     ```
  
     




* 测试
  1. 使用wireshark进行抓包 `sudo apt-get install wireshark`，可指定监听端口/协议`tcp port 80`
  2. telnet可测试IP地址与端口 `telnet 1.1.1.1 80`
  3. curl可测试http `curl http://1.1.1.1`
  4. nslookup可对域名进行DNS解析 `nslookup example.com`
  5. ping可测试是否可以接通`ping 1.1.1.1`
  6. nc可指定发送端，接收端的ip地址与端口进行测试 `nc -vz -s 192.168.2.102 -l 4000 192.168.5.41 4000`
  7. 查看在linux的某个端口上是否有程序运行 `netstat -tuln | grep :<port>`



## 4.Apache相关配置



* apache核心功能：开放源代码Web服务器软件

  1. 连接请求处理：Apache能够处理大量的并发连接请求，同时Apache的核心是模块化的，这意味着可以根据需要启用或禁用特定的功能模块（如为服务器上不同服务提供代理 -> proxy，proxy_http）
  2. 虚拟机支持：可以在单一Apache实例上托管多个网站，每个网站可以通过域名、IP地址或端口来区分。可通过在`/etc/apache2/sites-available/`路径下新建配置文件进行设置
  3. 安全性与日志管理：支持多种认证方式，如基于HTTP的基本认证、摘要认证等。同时支持SSL/TLS加密，用于HTTPS服务。提供详细的访问日志记录功能，并允许用户定义日志格式。
  4. 资源配置与管理：可以设置每个进程或每个用户的资源使用限制，例如最大内存使用量、CPU时间等。

* Apache安全认证模块配置

  1. 生成clouduser密钥配置（用户名为clouduser，密码会被进行加密储存）
     ```
     sudo htpasswd -c /etc/apache2/htpasswd.users clouduser
     ```

  2. 更改虚拟机配置文件 -> 加密部分仅可配置在location标签中（访问网址时要加“/”）

     ```
     <VirtualHost *:10005>
         ServerName localhost
         ProxyPreserveHost On
         <Location "/">
             AuthType Basic
             AuthName "Cloudreve Access"
             AuthUserFile /etc/apache2/htpasswd.users
             Require valid-user
     
             ProxyPass http://localhost:5212/ nocanon
         </Location>
     
         AllowEncodedSlashes NoDecode
     </VirtualHost>
     ```

* Apache日志

  1. 添加连接日志：配置日志格式 + 日志路径
     ```
     LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"" combined 
     CustomLog /var/log/apache2/proxy_access.log combined
     ```

     

## 5.NFS / Samba网络文件夹多设备共享



* NFS参考链接：
  * [Ubuntu最新版本(Ubuntu22.04LTS)安装nfs服务器及使用教程_ubuntu nfs-CSDN博客](https://blog.csdn.net/wkd_007/article/details/129092820)
  * [[Windows挂载NFS共享盘 - jackyzm - 博客园 (cnblogs.com)](https://www.cnblogs.com/jackyzm/p/10441493.html)](https://blog.csdn.net/weixin_43135696/article/details/118355742)
  * [【Linux磁盘映射到Windows】-CSDN博客](https://blog.csdn.net/qq_43501219/article/details/135003428)
  * [解决nfs-common.service is masked 问题-CSDN博客](https://blog.csdn.net/qq_46352005/article/details/133973762)
  * [运行bat时隐藏cmd窗口 - jack_Meng - 博客园 (cnblogs.com)](https://www.cnblogs.com/mq0036/p/14633154.html)

1. linux使用apt-get下载文件server或client的文件，更改server的防火墙设置确保111端口与2049端口打开，

2. 客户端需要使用systemclt设置nfs-common (client)的开机启动，在此过程中可能要unmask相关service，删除service文件并重启daemon。（**fstab会在启动时挂载，若nfs服务器无法访问，则会在启动界面卡很久！！！！！**）

   ```
   // 用于定义如何在Linux系统中挂载文件系统
   sudo vim /etc/fstab
   
   // 添加记录
   192.168.5.41:/home/yelu/nfsroot /home/yelu/nfsroot nfs defaults 0 0
   
   systemctl restart nfs-kernel-server.service
   ```

3. windows下载文件（专业版控制面板+软件），更改配置文件；重启服务（win+R输入services.msc）

4. 端口绑定与防火墙开放（由于版本问题无法在etc/sysconfig/nfs.conf中设置）
   ```
   // 查看nfs所使用的端口号
   rpcinfo -p
   
   // 自定义nfs文件网络服务所需要的端口号（为了端口映射）
   // 包含各种网络服务的名称及其对应的端口号（添加mountd与status -> 30003, 30005）
   sudo vim /etc/services
   
   // 设置内核参数的文件（添加fs.nfs.nlm_tcpport=30002）
   sudo vim /etc/sysctl.conf
   ```

5. 进行挂载（目前仅能通过指令挂载）

   ```
   New-PSDrive -Name Z -PSProvider FileSystem -Root '\\<IP address>\share' -Persist
   ```

6. 注册表修改（获取文件写入权限）

   ```
   // 进入注册表
   win + R 输入 regedit
   
   // 路径
   HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ClientForNFS\CurrentVersion\Default
   
   // 新建两项并重启
   ```

7. window开机自启动脚本 -> 利用“启动”文件夹

   * 按 Win + R 打开运行对话框。
   * 输入 shell:startup 并按 Enter 键打开**“启动”文件夹**。
   * 将你的脚本快捷方式或者批处理文件（.bat）复制到这个文件夹中。



* Samba（**没卵用**）

  1. 下载Samba，ubuntu22.04 apt-get可能出现依赖错误，可卸载有关依赖再进行安装

  2. 配置文件`sudo vim /etc/samba/smb.conf`
     ```
     [shared_directory]
       comment = Shared Directory
       path = /home/yelu/nfsroot
       browseable = yes
       read only = no
       guest ok = yes
     ```

  3. 重启服务 

     ````
     sudo systemctl restart smbd
     sudo systemctl enable smbd
     ````

  4. 开启防火墙端口
     ```
     sudo firewall-cmd --permanent --add-port=139/tcp
     sudo firewall-cmd --permanent --add-port=445/tcp
     ```

  5. 补充
     ```
     \\ 以下指令可查看包含smbjin'chegn
     sudo netstat -tlnp |grep smb
     ```
  
     



## 6.路由器系统制作



(1) 制作Linux内核 --> make（用于编译汇编指令）

* make指令 (参考：[Ubuntu之make：make命令行工具](https://blog.csdn.net/q7w8e9r4/article/details/133696384))

  1. make：make是一个构建工具，可以自动化编译和链接程序，其可通过读取Makefile文件来获取构建项目的规则和依赖关系。

  2. Makefile：由一系列规则组成，每个规则包含了目标、依赖和命令。

     * 目标：需要构建的文件或任务。
     * 依赖：目标所依赖的文件或任务。
     * 命令：执行构建任务的命令。
     * Makefile还可以包含变量、条件语句、循环等

  3. 实例1：编译一个cpp程序
     ```
     // 项目目录
     plaintextCopy codeproject/
     ├── src/
     │   ├── main.c
     │   ├── utils.c
     │   └── utils.h
     └── Makefile
     ```

     ```makefile
     # Makefile规则
     MakefileCopy code 
     CC = gcc                           # 定义了一个变量CC，任何使用$(CC)的地方都会被替换为gcc命令（编译器）
     CFLAGS = -Wall -g                  # 定义了编译器标志CFLAGS，替代$(CFLAGS)（用于输出错误，调试信息）
     all: myprogram                     # 默认目标，构建可执行文件
     myprogram: main.o utils.o          # 构建可执行文件，构建可执行文件，依赖于 main.o && utils.o
         $(CC) $(CFLAGS) $^ -o $@
     
     main.o: src/main.c src/utils.h     # 规定main.o这个对象文件依赖于源代码文件src/main.c和头文件src/utils.h。
         $(CC) $(CFLAGS) -c $< -o $@    # -c选项告诉GCC只编译并汇编，但不进行链接步骤。$<代表依赖的第一个文件，也就是src/main.c，而$@则是要生成的目标文件main.o
     
     utils.o: src/utils.c src/utils.h   # 编译utils.c文件
         $(CC) $(CFLAGS) -c $< -o $@
     
     clean:                             # 清理目标文件和可执行文件
         rm -f *.o myprogram
     ```



**linux系统内核**

* 参考链接
  1. [编译linux5.13内核与启动镜像](https://blog.csdn.net/TonyNomoney/article/details/118736375#:~:text=)
  2. [深度：一文看懂Linux内核！Linux内核架构和工作原理详解](https://blog.csdn.net/jinking01/article/details/104547290)

* 内核组件：系统调用接口、进程管理、内存管理、虚拟文件系统、网络堆栈、设备驱动程序、硬件架构
  
  ![img](https://s2.loli.net/2024/09/06/G3K9mSqdvI6R4rX.png)
  
  1. 内核是硬件与软件之间的一个中间层，将应用层序的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。
  2. 应用程序与硬件没有联系，只与内核有联系，内核是应用程序知道的层次中的最底层。
  3. 内核是一个资源管理程序。负责将可用的共享资源(CPU时间、磁盘空间、网络连接等)分配得到各个系统进程。
  4. 内核就像一个库，提供了一组面向系统的命令。
  
* 内核实现策略：微内核 / 宏内核，linux使用宏内核
  
  * 宏内核：内核的所有代码，包括子系统（如内存管理、文件管理、设备驱动程序）都打包到一个文件中。内核中的每一个函数都可以访问到内核中所有其他部分。目前支持模块的动态装卸(裁剪)。
  
* 内核与进程
  
  * 关系：当计算机启动时，BIOS或UEFI引导程序加载内核映像到内存中。内核开始初始化硬件和驱动程序，并加载必要的模块。内核初始化完成后，会执行一个称为`init`或`systemd`的程序，这个程序的PID为1。
  * 树形结构：每个进程都依赖于一个父进程。内核启动systemd (init)程序作为第一个进程，其中会包含一些进程依赖。该进程负责进一步的系统初始化操作。init进程是进程树的根，所有的进程都直接或者间接起源于该进程。
  
* 内核体系结构
  ![image-20240906163616864](https://s2.loli.net/2024/09/06/kiusg6IzqjywvVt.png)

  * 编程语言与操作系统：
    1.  C/C++ 应用程序默认会链接到 glibc 以访问必要的系统服务
    2. Java 应用程序运行在 Java 虚拟机 (JVM) 上，JVM 会处理与操作系统的交互。
    3. Python 应用程序通过 Python 解释器执行，解释器会负责底层的操作系统交互。
    4. .NET 应用程序运行在 .NET 运行时上，它也提供了与操作系统交互的抽象。
    5. Rust 应用程序可以链接到不同的 C 标准库，包括 glibc 或 musl (musl libc)，这取决于编译时的配置。
  * Linux 内核分层
    1. system call interface实现了一些基本的功能，例如 read、write、fork、exec。
    2. kernel是独立于体系结构的内核代码
    3. ADKC是依赖于体系结构的代码（如Board Support Package），位于硬件和操作系统之间，主要用于初始化硬件设备，并为操作系统提供硬件抽象层
  
* 内核文件：
  
  (1) 核心内容：linux操作系统内核主要使用 C 语言编写，并且包含少量的汇编语言代码（硬件交互部分）
  
  (2) 系统组成
  
  * 内存管理 (`mm/` 目录下的多个文件): 包括虚拟内存管理、物理内存分配、页面置换算法等。
  * 文件系统支持 (`fs`/ 目录): VFS子系统（支持多种文件系统如 ext4、XFS、Btrfs、FAT、NTFS 等）。
  * 网络栈 (`net/` 目录): 不包括网络设备驱动的网络子系统（实现了 TCP/IP 协议栈和其他网络协议的支持）。
  * 设备驱动程序 (`drivers/` 目录): 提供对各种硬件设备的支持，如网卡、声卡、USB 设备等。包含`vfs`虚拟文件系统等内容
  * 内核: (`kernel/`): 包含计算机中最核心与基础的程序，如`irq.c`处理来自硬件的中断请求，`module.c`允许动态加载和卸载内核模块，`power`进行包括 CPU 频率调节、休眠模式支持，`sched`CFS进程调度等。
  * 安全机制: (`security/` 目录): 包括 SELinux、AppArmor 等增强系统安全性的机制。
  * 进程间通信: (`ipc/` 目录): 进程间通信子系统，包括信号量、消息队列、共享内存等机制。
  * aarch: 体系结构相关的代码，例如arm, x86等等
  * dev(device): 包含了所有Linux系统中使用的外部设备(如外接的USB等) 的设备文件(用于控制外部设备)。(tty[0-63]: 虚拟终端，ttyS[0-3]: 串口)
  
  

**Linux操作系统内核制作**

1. gcc更新

   ```shell
   # 添加了一个APT源到你的Ubuntu系统的软件仓库列表中
   sudo add-apt-repository deb [arch=amd64] http://archive.ubuntu.com/ubuntu focal main universe
   # 更新本地的APT包索引
   sudo apt-get update
   sudo apt install gcc-8 g++-8
   # 切换系统gcc版本
   sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 800 --slave /usr/bin/g++ g++ /usr/bin/g++-8
   ```

2. gcc编译具体流程

   * 核心步骤：预处理（Preprocessing）、编译（Compiling）、汇编（Assembling）和链接（Linking）

   1. 预处理（Preprocessing）：在这个阶段，GCC读取源代码文件并通过预处理器处理其中的预处理指令（如`#include`、`#define`等）。预处理器会替换宏定义、包含头文件，并处理条件编译语句（如`#ifdef`、`#ifndef`等）。预处理的结果是一个没有预处理指令的“干净”的C/C++源代码文件。
   2. 编译（Compiling）：在编译阶段，GCC将预处理后的源代码翻译成汇编语言代码。编译器还会进行一系列的优化工作，如死代码消除、常量折叠等。如果源代码是汇编语言（如`.S`扩展名的文件），那么这个阶段会跳过，直接进入汇编阶段。
   3. 汇编（Assembling）：在这一阶段，汇编器将汇编语言代码转换为机器码，并生成一个或多个目标文件（如`.o`文件）。每个目标文件对应源代码中的一个源文件。目标文件包含了机器码、重定位信息（Relocation Information）以及符号表。符号表记录了函数和变量等符号的信息。
   4. 链接（Linking）：链接器负责将多个目标文件以及库文件中的机器码合并成一个单一的可执行文件或库文件。链接器通过符号表来解决不同文件之间函数和变量的引用。如果某个目标文件缺少符号表，链接器将无法正确解析该文件中的符号，从而导致链接错误

3. make相关指令

   ```shell
   # 参考链接：https://blog.csdn.net/Ididcan/article/details/6193199
   
   # Linux内核make命令行界面，提供功能/驱动编译选项：[*] 编译进内核；<M> 不编译入内核但可动态加载；[ ] 不包含；<> 可选择
   make menuconfig
   
   # 编译指令
   # -f <文件>: 指定Makefile文件的名称，默认为"Makefile"。
   # -C <目录>: 在指定的目录中运行make命令。
   # -j <并发数>: 指定同时运行的任务数，加快构建速度。
   # -k：继续构建过程中的下一个任务，即使前一个任务失败。
   # -n：模拟运行构建过程，不实际执行任何命令。
   # -s：静默模式，在构建过程中只显示关键信息。
   # all: bzImage1 bzImage2
   # bzImage1: ...
   # bzImage: ...
   make all            # 编译整个项目
   make bzImage -j 50  # 编译部分项目
   
   # 清理项目之前构建的内容
   make clean
   
   
   ```

   ![image-20240827143646782](https://s2.loli.net/2024/09/04/GXKdye3YzCfg4tD.png)

4. 编译错误指令解读

   ```shell
   # 第一行冒号前为文件路径+错误函数；第二行为（warning/error）的具体内容
   arch/x86/hyperv/hv_apic.c: In function ‘__send_ipi_one’:
   arch/x86/hyperv/hv_apic.c:196:1: warning: the frame size of 1032 bytes is larger than 1024 bytes [-Wframe-larger-than=]
   
   # 需要具体查询的报错
   make[1]: *** 没有规则可制作目标“debian/canonical-certs.pem”，由“certs/x509_certificate_list” 需求。 停止。
    
   ```

(2) BusyBox（制作根文件系统）

* initrd：一个压缩(通常是gz或者是lz4)过的cpio归档（压缩）文件，相对于真正的文件系统较小，包含一些必要的指令用于启动。其中包括了一个给内核提供初始化环境的最小根目录，会在真正的根目录可被挂载时切换ji掉。initrd由bootloader在加载内核的同时加载进内存，内核解压initrd到虚拟的ramdisk上,作为根目录，在内核启动完成后会挂载真正的系统。
* make：将busybox编译完之后，其产生的基本文件系统被输出到_install之中，可将其复制到做需要制作启动盘的文件夹中，并新建出系统所需要的各个文件夹（如etc/deb等）。在此之后新建控制台设备。
* bug
  1. stime：[busybox - BusyBox: The Swiss Army Knife of Embedded Linux](https://git.busybox.net/busybox/commit/?id=d3539be8f27b8cbfdfee460fe08299158f08bcd9)

(3) xorriso（制作ISO文件）





**机顶盒烧鸡**

[华为海思芯片机顶盒TTL线刷保姆小白教程_华为盒子论坛_ZNDS](https://www.znds.com/tv-1212880-1-1.html)

[TTL 刷机(海思) | 海纳思系统 (histb.com)](https://histb.com/docs/tutorial-basics/ttl-flash)

[海思Hi3798 MV/CV200避坑系列—— HC2910、DVC8178、HDC2100K_中国移动魔百盒_ZNDS](https://www.znds.com/tv-1215242-1-1.html)

https://www.right.com.cn/forum/thread-8218040-1-1.html

* arm系统架构介绍

  * 参考链接
    [ARMv7架构学习-CSDN博客](https://blog.csdn.net/weixin_37620587/article/details/109564968)

  * 运行原理：核心芯片本身的运行由各种不同的寄存器控制。这些寄存器用于存储和控制CPU的各种状态和配置信息，如PC、SR、通用寄存器等。操作系统/驱动程序则是将寄存器抽象为易于理解和使用的API和函数，通过这些抽象，操作系统和驱动程序可以实现更复杂的功能，如内存管理、进程调度、设备驱动、中断处理等（详见**嵌入式系统**笔记部分）。

    ![image-20240924183238408](https://s2.loli.net/2024/09/24/OXVKlRb91nZ3em8.png)

  * 工作模式：可通过调节CPRS寄存器切换模式
    1. User：大部分任务执行时（普通模式）
    2. FIQ：当高优先级中断产生时（特权模式）
    3. IRQ：当低优先级中断产生时（特权模式）
    4. Supervisor：复位/软件中断指令执行时（特权模式）
    5. Abort：存取异常时（特权模式）
    6. Undef：执行未定义指令时（特权模式）
    7. System：使用User模式相同寄存器集（特权模式）

* 芯片架构 & 工具链
  
  * 参考链接：
    [CPU_X86架构和ARM架构入门篇-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1862717)
  
  * 关系
    * 核心芯片架构：定义了系统的总体设计。核心芯片的架构（如arm）决定整体系统的选择与设计，其指令集和架构决定了工具链的选择。
    * 整体系统：整体系统由芯片架构决定，包含内存管理单元（MMU）、总线结构（如AXI或AHB）和外设接口（如GPIO、UART、SPI、I2C）
    * 工具链：必须支持目标芯片的指令集和架构，以确保开发过程的顺利进行。
    
  * 简单 / 复杂指令集：一个有睡觉指令，一个需要要换衣，熄灯，上床多个指令
    ![image-20240924185236686](https://s2.loli.net/2024/09/24/AYRwSxaFXl3QDCe.png)
    
  * 处理器架构
    
    ![image-20240924184629550](https://s2.loli.net/2024/09/24/jVzZ3IdLQyscaPR.png)
    
    * ARM：适用于移动设备、嵌入式系统和物联网设备。
    * x86：适用于个人电脑和服务器。
    * RISC-V：开源指令集架构，适用于各种嵌入式和高性能计算应用。
    * MIPS：适用于嵌入式系统和网络设备。
  
* 核心概念：
  * bootloader & fastboot：bootloader是分阶段的程序，负责初始化硬件并加载操作系统内核，fastboot算是bootloader的一个阶段或是其中的一种，主要用于用于快速启动和系统恢复。
  
* 刷机流程：在嵌入式设备上进行Linux系统的刷机。
  1. 制作启动盘：U盘格式化为标准的FAT32格式，确保99%的老旧CPU能够识别。U盘内下载对应型号的固件包（仅支持armv7系统），其中包括：
     - baseparam.img：基本系统参数配置。
     - bootargs.bin：启动参数配置。
     - fastboot.bin：快速启动模式的引导程序。
     - hi_kernel.bin：Linux内核镜像。
     - pq_param.bin：图像质量参数配置。
     - recoverybox32.ext4：恢复模式文件系统。
     - www_ecoo_top.ext4：Web界面或其他应用文件系统。
  2. 重启系统：插入U盘，短接对应的短接点（改变CPU的启动模式），再进行启动。一旦CPU从U盘读取到启动文件，系统将自动进入刷机模式，按照固件包中的指令进行刷机操作。
     1. CPU从USB设备读取并执行 `fastboot.bin`，`fastboot.bin` 读取 `bootargs.bin`获取启动参数。
     2. `fastboot.bin` 加载 `hi_kernel.bin`启动内核，内核加载 `baseparam.img`获取系统配置参数，内核加载`pq_param.bin`获取图像质量参数
     3. 内核加载恢复文件系统 `recoverybox32.ext4`，系统使用的文件系统`www_ecoo_top.ext4`





## 7.VPN 配置

* 参考链接
  1. [手把手教你搭建OpenVPN（保姆级教程） | Young's blog](https://blog.admin4j.com/linux/vpn/)



**操作步骤**

1. 安装配置证书软件--OpenVPN需要使用RSA加密

   ```
   sudo apt-get install openvpn easy-rsa
   make-cadir ~/openvpn-ca                      # 将easy-rsa可执行脚本复制到openvpn-ca文件夹
   vim ~/openvpn-ca/vars                        # 配置easy-rsa的基础信息
   
   ###
   export KEY_COUNTRY="CN"
   export KEY_PROVINCE="SX"
   export KEY_CITY="MyCity"
   export KEY_ORG="SYSU"
   export KEY_EMAIL="<MyEmail>"
   export KEY_OU="SDCS"
   
   # X509 Subject Field
   export KEY_NAME="server"
   ###
   ```

2. 生成 OpenVPN 所需的证书、私钥、Diffie-Hellman 参数 (此处由于easy-rsa版本不同所使用的运行脚本可能不同)

   ```shell
   ./easyrsa init-pki                #1、初始化，生成Public Key Infrastructure
   ./easyrsa build-ca                #2、创建根证书
   ./easyrsa gen-req server nopass   #3、创建server端证书和私钥文件
   ./easyrsa sign server server      #4、给server端证书签名
   ./easyrsa gen-dh                  #5、创建Diffie-Hellman文件，密钥交换时的Diffie-Hellman算法
   ./easyrsa gen-req client nopass   #6、创建client端的证书和私钥文件
   ./easyrsa sign client client      #7、给client端证书签名
   
   tree                              # 验证全部文件是否被正确生成
   ```

   * 整个流程说明：

     在 OpenVPN 建立连接时，首先会使用 **RSA** 算法进行身份验证。服务器将其证书签名，客户端通过根证书验证服务器证书的合法性，并确保连接的是正确的服务器。客户端同样也可以使用证书验证其身份（如果配置启用了双向认证）。一旦身份验证完成，Diffie-Hellman 算法将用于密钥交换，生成一个共享的秘密密钥，这个共享密钥用于之后的对称加密操作。

     在数据传输过程中，OpenVPN 使用 **对称加密算法**（如 AES）对通信内容进行加密和解密。与 RSA 相比，对称加密在传输大量数据时效率更高。所有的加密通信都基于之前通过 Diffie-Hellman 交换的共享密钥进行，而根证书、服务器证书和客户端证书则主要用于身份验证，确保双方通信的安全性和可信度。

3. 配置并运行OpenVPN
   ```json
   vim /etc/openvpn/server.conf
   systemctl start openvpn@server
   systemctl enable openvpn@server
   
   ### server.conf
   port 1194                                    #端口
   proto tcp                                    #协议
   dev tun                                      #采用路由隧道模式
   
   # 更新CA证书、公钥、私钥、DH参数的路径
   ca /etc/openvpn/server/severkey/ca.crt       #CA证书的位置
   cert /etc/openvpn/server/severkey/server.crt  #服务端公钥的位置
   key /etc/openvpn/server/severkey/server.key   #服务端私钥的位置
   dh /etc/openvpn/server/severkey/dh.pem        #Diffie-Hellman参数文件位置（用于密钥交换等）
   
   server 10.8.0.0 255.255.255.0                #给客户端分配的地址池
   push "route 172.16.1.0 255.255.255.0"        #允许客户端访问的内网网段
   ifconfig-pool-persist ipp.txt                #地址池记录文件位置，用于让OpenVPN客户端固定IP地址使用
   keepalive 10 120                             #存活时间，每10秒发送一次ping，120秒内如果未收到响应则视为连接断开
   max-clients 100                              #最多允许100个客户端连接
   status openvpn-status.log                    #状态日志位置，记录OpenVPN运行状态相关信息
   log /var/log/openvpn.log                     #OpenVPN日志记录位置
   verb 3                                       #日志详细程度等级（3表示相对适中的详细程度）
   client-to-client                             #允许客户端与客户端之间通信
   persist-key                                  #在Keepalive检测超时等情况重启VPN时，不重新读取私钥等密钥相关文件
   persist-tun                                  #检测超时等重启VPN时，保持tun设备始终处于连接（linkup）状态，避免网络先断开（linkdown）再连接（linkup）
   duplicate-cn                                 #允许客户端使用重复的通用名（Common Name，在证书相关场景下），即客户端密钥（证书和私钥）是否可以重复使用
   comp-lzo                                     #启用LZO数据压缩格式（如果客户端也支持才能生效）
   
   # 以下是新增的两行必要配置（原配置中缺失），用于指定OpenVPN以守护进程模式运行以及设置用户和用户组（一般设置为nobody用户等以提升安全性，此处示例用nobody，可根据实际需求调整）
   daemon
   user nobody
   group nobody
   ###
   ```

   可能产生问题与解决方案--核心为查看报错的log，其文件位置一般为/var/log/openvpn.log
   ```shell
   # 查看报错文件信息
   sudo tail -f /var/log/openvpn.log
   
   # 无法找到密钥文件--openVPN可能需要将所需密钥转移到其对应的工作目录（可在systemd配置文件中查看）
   cp <my-keys> /etc/openvpn/server/<your-floder>
   
   # 用户组问题--建议配置文件中使用nobody用户组，以下为其对应的新建方式
   grep nobody /etc/group            # 查看是否有用户组
   sudo groupadd nobody              # 创建用户组
   sudo useradd -r -g nobody nobody  # 创建对应用户
   ```



**用户端配置**

1. 下载与配置openVPN
   ```shell
   sudo apt-get install openvpn
   vim /etc/openvpn/client.conf
   
   ### /etc/openvpn/client.conf
   client
   dev tun
   proto tcp
   remote <server_ip> 1194
   resolv-retry infinite
   nobind
   ca <file_path>/ca.crt
   cert <file_path>client.crt
   key <file_path>client.key
   verb 3
   persist-key
   comp-lzo
   log /var/log/openvpn.log
   ###
   ```
   
2. 添加密钥
   ```shell
   # 1.将服务器上所生成的ca.crt client.crt client.key传输到client的openvpn的工作目录当中,可使用scp
   # 2.在client/server上生成key+req后在服务端签字再下发
   ./easyrsa init-pki
   ./easyrsa gen-req <Common_Name> nopass
   ./easyrsa sign client <Common_Name>
   
   systemctl start openvpn@client
   systemctl enable openvpn@client
   ```
   
3. windows配置方法
   ```
   # 如下创建文件夹(以下文件须在一个文件夹内)
   
       目录: C:\Program Files\OpenVPN Connect\my_server
   
   Mode                 LastWriteTime         Length Name
   ----                 -------------         ------ ----
   -a----        2024/12/14     18:56           1176 ca.crt
   -a----        2024/12/14     19:00           4457 client.crt
   -a----        2024/12/14     18:59           1704 client.key
   -a----        2024/12/14     23:08            340 client.ovpn
   
   ### client.ovpn
   client
   dev tun
   proto udp
   remote <server_ip> 1194        #注意此处更改为openvpn服务端代码
   resolv-retry infinite
   nobind
   ca ca.crt
   cert client.crt
   key client.key
   verb 3
   persist-key
   comp-lzo
   ###
   ```

4. 绑定ip地址
   ```shell
   mkdir -p /etc/openvpn/ccd
   # 向原配置文件中新增ccd
   
   ### server.conf
   client-config-dir /etc/openvpn/ccd
   ###
   
   echo "ifconfig-push <assigned_ip> 255.255.255.0" > /etc/openvpn/ccd/<common_name>
   ```

5. 补充：相关服务的启动与停止
   ```shell
   sudo systemctl start openvpn@client
   sudo systemctl stop openvpn@client
   sudo systemctl restart openvpn@server
   
   # 自启动相关配置
   sudo systemctl enable openvpn@server
   ```
   



## 8.动态更新维护DNS服务

* 解决方案：本地电脑当发现本地IPv6地址变更之后向云服务器发送DNS解析变更请求，该过程通过DNS云服务器提供的api与SDK以实现。



**操作步骤**

1. 本地建立更新脚本
   ```python
   import sys
   import requests
   import json
   import time
   import os
   from Tea.core import TeaCore
   from typing import List
   from alibabacloud_alidns20150109.client import Client as DnsClient
   from alibabacloud_tea_openapi import models as open_api_models
   from alibabacloud_alidns20150109 import models as dns_models
   
   class IPUpdate:
       LOG_FILE = "log.txt"
   
       @staticmethod
       def log_message(message: str) -> None:
           """
           Log messages to a file.
           """
           timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
           with open(IPUpdate.LOG_FILE, "a") as log_file:
               log_file.write(f"[{timestamp}] {message}\n")
           print(message)  # Optional: Also print to console
   
       @staticmethod
       def initialization(region_id: str) -> DnsClient:
           """
           Initialize client with region_id and access keys
           """
           config = open_api_models.Config()
           # AccessKey ID and AccessKey Secret
           config.access_key_id = os.environ['ACCESS_KEY_ID']
           config.access_key_secret = os.environ['ACCESS_KEY_SECRET']
           # Region ID
           config.region_id = region_id
           return DnsClient(config)
   
       @staticmethod
       def describe_domain_records(client: DnsClient, domain_name: str, rr: str, record_type: str) -> dns_models.DescribeDomainRecordsResponse:
           """
           Get DNS records for the domain
           """
           req = dns_models.DescribeDomainRecordsRequest()
           req.domain_name = domain_name
           req.rrkey_word = rr
           req.type = record_type
           try:
               resp = client.describe_domain_records(req)
               IPUpdate.log_message("Fetching domain records...")
               return resp
           except Exception as error:
               IPUpdate.log_message(f"Error fetching domain records: {error}")
           return None
   
       @staticmethod
       def update_domain_record(client: DnsClient, req: dns_models.UpdateDomainRecordRequest) -> bool:
           """
           Update DNS record with new IPv6 address
           """
           try:
               resp = client.update_domain_record(req)
               IPUpdate.log_message(f"DNS record updated successfully: {resp.body.record_id}")
               return True
           except Exception as error:
               IPUpdate.log_message(f"Error updating DNS record: {error}")
               return False
   
       @staticmethod
       def get_current_ipv6() -> str:
           """
           Get current global IPv6 address from local system.
           """
           import subprocess
           import re
   
           try:
               # Use ifconfig or ip command to get IPv6 address
               result = subprocess.run(['ifconfig'], stdout=subprocess.PIPE, universal_newlines=True)
               ipv6_match = re.search(r'inet6 (?!fe80)[a-f0-9:]+', result.stdout)
               if ipv6_match:
                   ipv6_address = ipv6_match.group().split()[1]
                   IPUpdate.log_message(f"Current IPv6 address: {ipv6_address}")
                   return ipv6_address
           except Exception as e:
               IPUpdate.log_message(f"Error fetching IPv6 address: {e}")
               return None
   
       @staticmethod
       def read_last_ipv6() -> str:
           """
           Read stored last IPv6 address from file
           """
           try:
               with open('last_ipv6.txt', 'r') as file:
                   last_ipv6 = file.read().strip()
                   IPUpdate.log_message(f"Last IPv6: {last_ipv6}")
                   return last_ipv6
           except FileNotFoundError:
               IPUpdate.log_message("No last IPv6 found, assuming first run.")
               return None
   
       @staticmethod
       def store_ipv6(ipv6_address: str) -> None:
           """
           Store the current IPv6 address to file
           """
           with open('last_ipv6.txt', 'w') as file:
               file.write(ipv6_address)
               IPUpdate.log_message(f"Stored new IPv6 address: {ipv6_address}")
   
       @staticmethod
       def main() -> None:
           regionid = "cn-hangzhou"
           domain_name = "yelu314.ink"
           rr = "main"
           record_type = "AAAA"
           client = IPUpdate.initialization(regionid)
           cnt = 0
   
           while (cnt < 3):
               current_ipv6 = IPUpdate.get_current_ipv6()
               if current_ipv6 is None:
                   IPUpdate.log_message("Unable to fetch IPv6 address. Retrying in 60 seconds...")
                   time.sleep(60)
                   continue
   
               last_ipv6 = IPUpdate.read_last_ipv6()
   
               if current_ipv6 != last_ipv6:
                   IPUpdate.log_message(f"IPv6 has changed from {last_ipv6} to {current_ipv6}")
                   resp = IPUpdate.describe_domain_records(client, domain_name, rr, record_type)
                   if resp and resp.body.domain_records.record:
                       record = resp.body.domain_records.record[0]
                       record_id = record.record_id
                       req = dns_models.UpdateDomainRecordRequest()
                       req.rr = rr
                       req.record_id = record_id
                       req.value = current_ipv6
                       req.type = record_type
   
                       if IPUpdate.update_domain_record(client, req):
                           IPUpdate.store_ipv6(current_ipv6)
                       else:
                           IPUpdate.log_message("DNS update failed. Retrying in 60 seconds...")
                   else:
                       IPUpdate.log_message("No DNS records found to update. Retrying in 60 seconds...")
               else:
                   IPUpdate.log_message("IPv6 address is unchanged.")
   
               cnt += 1
               time.sleep(10)
   
   if __name__ == '__main__':
       IPUpdate.main()
   ```
   
2. 设置开机自启动
   ```shell
   # 新建启动项
   sudo vim /etc/systemd/system/ipv6_script.service
   
   ### ipv6_script.service--若脚本调用环境变量则需要在service中手动添加Environment
   [Unit]
   Description=IPv6 Address Fetching Script
   After=network.target
   
   [Service]
   User=yelu
   WorkingDirectory=/home/yelu/ipv6update
   Environment="ACCESS_KEY_ID="
   Environment="ACCESS_KEY_SECRET="
   ExecStart=/bin/bash -c "source /home/yelu/ipv6update/ipv6update/bin/activate && /home/yelu/ipv6update/ipv6update/bin/python3 /home/yelu/ipv6update/sendIP.py"
   Restart=always
   
   [Install]
   WantedBy=multi-user.target
   ###
   
   # 重载 + 启动 + 自启动服务
   sudo systemctl daemon-reload
   sudo systemctl start ipv6_script.service
   sudo systemctl enable ipv6_script.service
   sudo systemctl status ipv6_script.service
   ```
   
   1. python运行环境的管理与隔离（使用venv）
   
      ```shell
      # 创建虚拟环境myenv(在当前目录)
      python3 -m venv myenv
      
      # 激活虚拟环境
      source myenv/bin/activate
      ```
   
      

## 9. Linux

![image-20250716140755840](https://cdn.jsdelivr.net/gh/laotianye01/img_bed@image/note_image/image-20250716140755840.png)

* 参考链接
  1. [bili](https://www.bilibili.com/video/BV1aZVAz7Ei6/)
  
  

### 指令集与汇编

* 核心：人类语言与计算机硬件功能间的桥梁 -- 汇编语言是与硬件紧密相连的，需要了解计算机硬件工作流程(CPU，寄存器，内存)才能真正的理解汇编



**ARM架构(以Cortex-M4为例)**

* ARM架构基本信息

  * ARM架构为精简指令集的医院
  * 处理器核心b包含寄存器，ALU, 数据通路与一些逻辑单元

* CPU工作流程: fetch, decode, and execution

  ![image-20240229140151612](https://s2.loli.net/2024/02/29/A2worpfuJmeRUIg.png)

* **寄存器(16*32-bit registers)**

  * 寄存器状态说明文档: [ARM架构基本寄存器](https://blog.csdn.net/weixin_47447179/article/details/122884198#xPSR_49)

  * 寄存器存在于CPU内部，其为计算机中写入读取最快的单元

  * 寄存器功能 

    ![image-20240229141205869](https://s2.loli.net/2024/02/29/vYk5n69lb8jQNL7.png)

    * R0 ~ R12: 通用寄存器
    * R13: Stack Pointer (指向堆栈顶部，其地址为MSP或PSP)
    * R14: Link Register (存储函数的返回地址)
    * R15: Program Counter (存储下一条指令的地址) 
    * PRIMASK: 是否允许interrupt
    * xPSR: Process State Register (存储当前进程状况)
      * APSR: APSR主要包含条件执行的结果标志，比如进位（C）、零（Z）、溢出（V）、负（N）等，这些标志用于决定条件指令是否执行。
      * EPSR:包含执行状态信息的部分，最显著的是T（Thumb状态）位，指示处理器当前是否处于Thumb指令集状态（16位指令宽度）还是ARM指令集状态（32位指令宽度）
      * IPSR: 存储当前处理器的中断或异常模式下的状态，特别是它记录了当前正在服务的中断或异常编号。

* 内存图(Memory Map)

  ![image-20240229141928555](https://s2.loli.net/2024/02/29/t8Aj5i4Kl3WURdv.png)

  * **property**
    1. 4GB内存大小
    2. 512MB = 00000000 ~ 1FFFFFFF ($2^1 * (2^4)^7=2^{29}byte$) ---> **每一个F对应 $2^4$ Bytes，计算时切记0也算一个**，算出来的数$\div 1024$是KB，$\div 1024^2$是MB
  * 内存区域划分
    1. Code Region: store program code, constant data --> On-chip memory
    2. SRAM Region: store data (heap & stack), program code --> program code
    3. Peripheral Region: used for on-chip peripherals (外围设备) via hardware busses

* Program Image

  ![image-20240229142630859](https://s2.loli.net/2024/02/29/pHYEWozsk8Q2KUG.png)

  * components:
    1. Vector table: includes the starting addresses of exceptions and value of main stack point (MSP)
    2. C start-up routine
    3. Program code: application code and data;
    4. C library code: program codes for C library
  * Reset Behavior (fault handling)
    1. First reads the initial MSP value to set up the stack
    2. Then reads the reset vector;
    3. Branches to the start of the program execution address (reset handler);
    4. Subsequently executes program instruction

* 字节序

  ![image-20240301001412183](https://s2.loli.net/2024/03/01/xbAjUrdhYFXOoLD.png)

  * categories :
    1. Little endian: lowest byte is stored in bit 0 to bit 7
    2. Big endian: lowest byte in bit 24 to bit 31



**汇编指令**

* 汇编语言命令分类

  1. 数据传输指令：数据在寄存器，内存间操作
  2. 算术逻辑运算指令：如加减法
  3. 标签指令：用于代码跳转的标记，不用于封装，名称后跟一个冒号（可直接jump到标签位置）
  4. 控制转移指令：控制程序执行流程，如jump
  5. 位操作指令：对数据的位操作，如逻辑左/右移实现乘除法
  6. 栈操作指令：堆栈操作如push
  7. 特殊指令：如中断触发等
  8. 伪指令：用于提供信息或控制汇编过程，如.data

* 一些arm汇编语言例子

  ```assembly
  ;;; 数组操作
  ;;; 以下命令中第一部0000a0代表系统当前执行指令的位置 第二部分4b1b代表当前命令的机器码
  ;;; annotation, meaning that following code function writen in C
  ;;;76 i = buff2[0] + buff2[n];  
  
  00009e 4602 MOV r2,r0         ; load n
  
  0000a0 4b1b LDR r3,|L1.272|
  0000a2 781b LDRB r3,[r3,#0]   ; buff2
  0000a4 4c1a LDR r4,|L1.272|
  0000a6 5ca4 LDRB r4,[r4,r2]
  0000a8 1918 ADDS r0,r3,r4
  |L1.272|                      ; 将标签|L1.272|与buff2的启示地址关联
  	DCD buff2
  	
  ;;; 条件判断与标签(用于跳转)
  ;;; while (condition) {
  ;;; 	stat1; 
  ;;; 	stat2;
  ;;; }
  
  	{COND_SETUP …}
  COND
      {COND_EVAL …} B<cond> EXIT
      {INSTS1 …}
      {INSTS2 …}
      B COND
  EXIT
  
  ;;; 函数实现(跳转到标签处运行，加载相应数据)
  ;;;int fun(int n){
  ;;;	if (n <= 1){
  ;;;		return 1;
  ;;;	}
  ;;;	return (n * fun(n - 1));
  ;;;}
  
  ;;;assign n is store in R0
  fun:
      CMP R0, #1          ; Compare n with 1
      BLE base_case       ; If n <= 1, go to base_case
      PUSH {LR}           ; Save the link register (return address)
      PUSH {R0}           ; Save the current value of n
      SUB R0, R0, #1      ; n = n - 1
      BL fun              ; Recursive call: fun(n-1)
      POP {R1}            ; Restore the previous value of n from the stack
      POP {LR}            ; Restore the link register
      MUL R0, R0, R1      ; R0 = n * fun(n-1)
      BX LR               ; Return
  base_case:
      MOV R0, #1          ; Return 1 for the base case
      BX LR               ; Return
  ```

* X86汇编例子

  ```assembly
  ; 指明程序在内存中的加载地址，对于引导扇区通常是加载到内存地址 0x7c00 中
  ; 以下代码与数据均作为字节加载到内存当中，msg:(标签)可用于在内存中寻址
      ORG		0x7c00	
      
  ; 以下省略FAT12格式软盘专用的代码
      JUMP	entry			; 跳转指令
      ; ......
      
  ; 初始化寄存器
  entry:
  		MOV		AX,0			; 初始化寄存器
  		MOV		SS,AX
  		MOV		SP,0x7c00
  		MOV		DS,AX
  		MOV		ES,AX
  
  		MOV		SI,msg          ; 将所需打印的数据首地址加载到SI寄存器中
  		
  ; putloop: 将 msg 中写入的数据一个一个地显示出来直到数据变成0之后进入无限循环
  putloop:
  		; 以下显示字符的方式为调用bios程序所实现的
  		MOV		AL,[SI]
  		ADD		SI,1			; 给SI+1
  		CMP		AL,0            ; 将两个值做差，为零时零标志 (ZF) 将被设置为 1
  		JE		fin
  		MOV		AH,0x0e			; 显示一个文字
  		MOV		BX,15			; 指定字符颜色
  		INT		0x10			; 调用显卡BIOS
  		JMP		putloop
  		
  ; fin: 使 CPU 进入待机，无限循环
  fin:
  		HLT						; 让CPU停止等待指令
  		JMP		fin				; 无限循环
  		
  ; 数据段内容
  msg:
  		DB		0x0a, 0x0a		; 换行两次
  		DB		"hello, world"
  		DB		0x0a			; 换行
  		DB		0
  
  		RESB	0x7dfe-$		; 填写0x00，直到0x001fe
  
  		DB		0x55, 0xaa
  ```



**手搓os相关工具讲解**



* 工具来源: [tolset](https://github.com/sky5454/30daysMakeOS-Origin-ISOfiles/tree/master/30days-Origin-ISOfiles/tolset)--x86系统下操作系统开发所使用的工具包



**nask**

* 功能: 作者自己编写x86汇编反汇编器(参考nasm)，用于将汇编语言编译为二进制语言

* 使用
  ```
  // 将汇编代码编译为二进制文件
  tolset\z_tools\nask.exe os_code_chi\01_day\helloos.nas os_code_chi\01_day\helloos.img
  ```

**make**

* 功能: make工具是一个自动化执行工具，其可以调用系统内布库并依据makefile定义的规则去顺序执行命令，其一般用于项目编译(如自动调用gcc指令)

* 运行环境: make指令一般会继承父进程的环境变量(如在bash中运行时其会继承终端bashrc中所设置的全部环境变量)

* 使用: 在有makefile的文件夹中使用make执行特定指令，若部分依赖不满足则其会自动在makefile中检所对应依赖是否能被生成
  ```makefile
  # 默认动作
  
  default :
  	../z_tools/make.exe img
  	
  # 执行`make -r <order>`如ipl.bin或install可以执行对应指令下的命令行内容
  
  # 镜像文件生成
  
  ipl.bin : ipl.nas Makefile # 当当前文件夹中有ipl.nas与Makefile时可以生成ipl.bin
  	../z_tools/nask.exe ipl.nas ipl.bin ipl.lst
  
  helloos.img : ipl.bin Makefile
  	../z_tools/edimg.exe   imgin:../z_tools/fdimg0at.tek \
  		wbinimg src:ipl.bin len:512 from:0 to:0   imgout:helloos.img
  
  # 其他指令
  
  asm :
  	../z_tools/make.exe -r ipl.bin
  
  img :
  	../z_tools/make.exe -r helloos.img
  
  run :
  	../z_tools/make.exe img
  	copy helloos.img ..\z_tools\qemu\fdimage0.bin
  	../z_tools/make.exe -C ../z_tools/qemu
  
  install :
  	../z_tools/make.exe img
  	../z_tools/imgtol.com w a: helloos.img
  
  clean :
  	-del ipl.bin
  	-del ipl.lst
  
  src_only :
  	../z_tools/make.exe clean
  	-del helloos.img
  ```

  

**qemu**

* 功能: 轻量级虚拟机软件，可用于运行编译好的操作系统(轻量级的vmware)

* qemu文件结构介绍
  1. 核心程序 (qemu.exe)
  2. 模拟硬件所需的固件文件 (bios.bin, vgabios.bin)
  3. 提供图形和输入输出支持的库文件 (SDL.dll)
  4. 启动操作系统的虚拟磁盘镜像 (fdimage0.bin) 和一个方便启动的批处理脚本 (qemu-win.bat)
* 使用
  ```
  // 将生成的系统镜像复制到虚拟机中
  copy helloos.img ..\z_tools\qemu\fdimage0.bin
  
  // 使用qemu中makefile所定义的逻辑启动虚拟机(其中通过调用.bat设置了环境变量 + 调用了qemu.exe)
  \z_tools\make.exe -C ../z_tools/qemu
  ```




### linux驱动管理

* 参考资料
  1. [linux驱动开发](https://blog.csdn.net/qq_44814825/article/details/129107911)

* 操作系统基本架构
  <img src="https://cdn.jsdelivr.net/gh/laotianye01/img_bed@image/note_image/b8ce43220c408d99eb64c2b9d35d122.png" alt="b8ce43220c408d99eb64c2b9d35d122" style="zoom: 18%;" />
  
  * 内核态: 代码具有对硬件的所有控制权限。可以执行所有CPU指令，可以访问任意地址的内存
  * 用户态: 代码没有对硬件的直接控制权限(->系统接口)，也不能直接访问地址的内存(->页表映射的虚拟地址)。
  
* 驱动设备类型
  1. 字符设备驱动: 能够像字节流(文件)一样访问的设备，需实现open、close、read和write系统调用(与cpp中接口的思想相类似) -- lcd，键盘，串口等
  2. 块设备驱动: 通过固定大小的buffer cache访问，且支持任意块存取，一般通过文件系统访问 -- 硬盘等设备
  3. 网络设备驱动: 通过套接字(socket)函数fan访问，可通过网络接口与外部设备通讯 -- 蓝牙，网卡设备等

* 驱动设备功能

  1. 对设备初始化和释放
  2. 把数据从内核传送到硬件和从硬件读取数据
  3. 读取应用程序传送给设备文件的数据和回送应用程序请求的数据
  4. 检测和处理设备出现的错误

* 驱动程序的调用
  <img src="https://cdn.jsdelivr.net/gh/laotianye01/img_bed@image/note_image/image-20250721141923998.png" alt="image-20250721141923998" style="zoom: 25%;" />

  * (以字符设备为例)驱动程序加载成功后，其会在`\dev`文件下生成对应设备文件，应用程序通过对`\dev\XXX`执行相应操作(如write/read)便可对硬件操作--应用程序通过**系统调用**(进入内核态)，使操作系统调用对应的驱动函数
    ![image-20250721142611250](https://cdn.jsdelivr.net/gh/laotianye01/img_bed@image/note_image/image-20250721142611250.png)
  * 具体执行流程
    ![image-20250721143231479](https://cdn.jsdelivr.net/gh/laotianye01/img_bed@image/note_image/image-20250721143231479.png)
    1. 计算机启动加载一个驱动模块时会产生一个设备文件，其有唯一对应的inode结构体
    2. 应用层调用open函数打开设备文件，对于上层open调用到内核时会发生一次软中断，从用户空间进入到内核空间
    3. open会调用到sys_open(内核函数)，sys_open根据文件的地址，找到设备文件对应的struct inode结构体描述的信息，可以知道接下来要操作的设备类型（字符设备还是块设备），还会分配一个struct file结构体
    4. open会调用到sys_open(内核函数)，sys_open根据文件的地址，找到设备文件对应的struct inode结构体描述的信息，可以知道接下来要操作的设备类型（字符设备还是块设备），还会分配一个struct file结构体
    5. 每个字符设备都有一个struct cdev结构体。此结构体描述了字符设备所有信息，其中最重要的一项就是字符设备的操作函数接口
    6. 找到struct cdev结构体后，linux内核就会将struct cdev结构体所在的内存空间首地址记录在struct inode结构体i_cdev成员中，将struct cdev结构体中的记录的函数操作接口地址记录在struct file结构体的f_ops成员中
    7. 执行xxx_open驱动函数

* 驱动开发方式

  * 将驱动程序编译进内核---不灵活

  * 将驱动编译为模块(linux中为.ko文件)，内核启动后可通过相应命令加载模块(到内核空间---灵活，便于二次开发

    

* 设备树

  * 定义: 描述硬件的数据结构，存放了设备的信息，包括CPU或CPU，内存，总线和其他一些外设。

  * 编译存储与加载
    ![575a7962468412cd0682fcf474fa3d5](https://cdn.jsdelivr.net/gh/laotianye01/img_bed@image/note_image/575a7962468412cd0682fcf474fa3d5.png)

    * DTS: 设备树源码文件，每一款硬件信息可以单独写一份xxxx.dts(dtsi)
    * DTC: 编译DTS的工具
    * DTB: 编译后二进制的设备树文件，通过bootloader加载至内核
    * 设备启动后，设备信息会被初始到根文件系统的/proc/devicetree 目录下根据节点名字创建的不同文件夹中

  * DTS语法 && 设备树节点 -- 设备树的头文件扩展名为`.dtsi`, 在`.dts`设备树文件中, 还可以通过“#include”来引用`.h`, `.dtsi` 和`.dts`文件
    ```c
    // 节点的属性通过键—值对描述
    uart1: serial@02020000 {
        // compatible属性设置了硬件驱动模块的名称，linux系统会根据该名称在内核中寻找对应的驱动（与驱动程序of表进行匹配）
        compatible = "fsl,imx6ul-uart",
            "fsl,imx6q-uart", "fsl,imx21-uart";
        // 描述子节点的地址信息: 起始地址 + 长度
        reg = <0x02020000 0x4000>;
        interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>;
        clocks = <&clks IMX6UL_CLK_UART1_IPG>,
            <&clks IMX6UL_CLK_UART1_SERIAL>;
        clock-names = "ipg", "per";
        // 描述设备状态
        status = "disabled";
    };
    
    // 系统启动后，设备信息的文件被加载到操作系统的设备树结构体中，每个设备都是一个节点，叫做设备节点
    struct device_node {
        const char *name; /* 节点名字 */
        const char *type; /* 设备类型 */
        phandle phandle;
        const char *full_name; /* 节点全名 */
        struct fwnode_handle fwnode;
     
        struct property *properties; /* 属性, 为一个结构体 */
        struct property *deadprops; /* removed 属性 */
        struct device_node *parent; /* 父节点 */
        struct device_node *child; /* 子节点 */
        ...
    }
    
    // 属性结构体
    struct property {
        char *name; /* 属性名字 */
        int length; /* 属性长度 */
        void *value; /* 属性值 */
        struct property *next; /* 下一个属性 */
        unsigned long _flags;
        unsigned int unique_id;
        struct bin_attribute attr;
    }
    
    // 内核中用于获取设备树中的节点或者属性信息的函数统一有前缀of_
    struct device_node *of_find_node_by_name(struct device_node *from,const char *name);
    ...
    inline struct device_node *of_find_node_by_path(const char *path);
    ...
    void __iomem *of_iomap(struct device_node *np,  int index);  // 获取内存地址所对应的虚拟地址
    
    // 设备树函数使用示例
    int ret;
    u32 regdate[14];
    const char *str;
    struct property *proper;
    /* 1 、获取设备节点： */
    dtb_led.nd = of_find_node_by_path("/songwei_led");
    if(dtb_led.nd == NULL)
    {
        printk("songwei_led node can not found!\r\n");
        return -EINVAL;
    }else
    {
        printk("songwei_led node has been found!\r\n");
    }
    
    /* 2 、获取 compatible  属性内容 */
    proper = of_find_property(dtb_led.nd ,"compatible",NULL);
    if(proper == NULL) 
    {
        printk("compatible property find failed\r\n");
    } else 
    {
        printk("compatible = %s\r\n", (char*)proper->value);
    }
    
    /* 3 、获取 status  属性内容 */
    ret = of_property_read_string(dtb_led.nd, "status", &str);
    if(ret < 0)
    {
        printk("status read failed!\r\n");
    }else 
    {
        printk("status = %s\r\n",str);
    }
    
    /* 4 、获取 reg  属性内容 */
    ret = of_property_read_u32_array(dtb_led.nd, "reg", regdate, 10);
    if(ret < 0) 
    {
        printk("reg property read failed!\r\n");
    }else 
    {
        u8 i = 0;
        printk("reg data:\r\n");
        for(i = 0; i < 10; i++)
            printk("%#X ", regdate[i]);
        printk("\r\n");
    }
    ```



* 字符设备驱动
  ![image-20250721164543732](https://cdn.jsdelivr.net/gh/laotianye01/img_bed@image/note_image/image-20250721164543732.png)

* 手动驱动加载流程

  1. 将驱动程序编译成`.ko`文件
  2. 使用`insmod XXX.ko`加载驱动到内核
  3. 手动创建驱动节点文件`mknod /dev/chrdevbase c 200 0`

* (自动)驱动程序架构

  ```c
  // 字符驱动程序样例
  #include <linux/io.h>                   // 包含用于寄存器虚拟内存映射函数的头文件--ioremap && iounmap
  
  #define NEWCHR_CNT 1
  #define NEWCHR_NAME "NEWCHR"
  //内核缓存区
  static char readbuf[100];						//读数据缓存
  static char writebuf[100];						//写数据缓存
  static char kerneldata[] = {"kernel data!"};	//测试数据
  //硬件寄存器
  #define GPIO_TEST_BASE (0x01234567) 	//宏定义寄存器映射地址
  static void __iomem *GPIO_TEST;			// __iomem 类型的指针，指向映射后的虚拟空间首地址
  
  /* newchr设备结构体 */
  struct newchr_dev{
  	dev_t devid;			/* 设备号 	 */
  	struct cdev cdev;		/* cdev 	*/
  	struct class *class;	/* 类，用于在dev生成设备文件 	*/
  	struct device *device;	/* 设备 	 */
  	int major;				/* 主设备号	  */
  	int minor;				/* 次设备号   */
  };
   
  struct newchrled_dev newchr;	/* newchr设备 */
  
  //打开设备(驱动函数)，open操作会创建file结构体，将内核中指向设备数据结构的指针放置到struct file的私有数据中，便可通过read&write进行读写
  static int chrdevbase_open(struct inode *inode, struct file *filp) 
  {
  	filp->private_data = &newchr; /* 设置私有数据 */
  	return 0;
  }
  
  // 从设备读取数据(驱动函数)
  static ssize_t chrdevbase_read(struct file *filp , char __user *buf , size_t cnt , loff_t *offt) 
  {
  	int retvalue = 0;
  	unsigned char databuf[1];
  	//读取私有数据
  	struct newchr_dev *dev = (struct newchr_dev *)filp->private_data;
      // 读取硬件寄存器
      #if 0  
          //读取寄存器状态
          databuf[0] = readl(GPIO_TEST);
          retvalue = copy_to_user(buf , databuf, cnt);
      //读取内核内存
      #else	
          //测试数据拷贝到读数据缓存中
          memcpy(readbuf , kerneldata , sizeof(kerneldata));  
          //内核中数据（读缓存）拷贝到用户空间
          retvalue = copy_to_user(buf , readbuf , cnt);
      #endif
  
          if(retvalue == 0) printk("kernel senddate ok!\n");   
          else printk("kernel senddate failed!\n");
          return 0;
  }
  
  //向设备写数据(驱动函数)
  static ssize_t chrdevbase_write(struct file *filp, const char __user *buf, size_t cnt , loff_t *offt) 
  {
  	int retvalue = 0;
  	//读取私有数据
  	struct newchr_dev *dev = (struct newchr_dev *)filp->private_data;
      //写硬件寄存器
      #if 0
          writel(buf[0],GPIO_TEST);
      //写内核缓存
      #else
          //用户数据拷贝到内核空间（写缓存）
          retvalue = copy_from_user(writebuf , buf ,cnt);
      #endif
          if(retvalue == 0) printk("kernel recevdate : %s\n",writebuf);
          else printk("kernel recevdate failed!");
          return 0;
  }
  
  //关闭/释放设备(驱动函数)
  static int chrdevbase_release(struct inode *inode , struct file *filp) 
  {
  	return 0;
  }
  
  //设备操作函数，将驱动程序与字符设备的标准系统调用相关联，实现用户空间的访问
  static struct file_operations chrdevbase_fops = {
      .owner = THIS_MODULE,
      .open = chrdevbase_open,
      .read = chrdevbase_read,
      .write = chrdevbase_write,
      .release = chrdevbase_release,
  };
  
  /* 驱动入口函数 */
  static int __init chrdevbase_init(void)
  {
  	int retvalue = 0;
  	//寄存器物理映射，物理地址映射到虚拟地址指针
  	GPIO_TEST= ioremap(GPIO_TEST_BASE, 4);
  	
  	//申请设备号
      if(newchr.major)		//静态申请
      {
          newchr.devid = MKDEV(newchr.major , 0);
          register_chrdev_region(newchr.devid, NEWCHR_CNT,NEWCHR_NAME);
      }else					//动态申请
      {
          alloc_chrdev_region(&newchr.devid , 0 , NEWCHR_CNT , NEWCHR_NAME);
          newchr.major = MAJOR(newchr.devid);
          newchr.minor = MINOR(newchr.devid);
      }   
      printk("newche major=%d,minor=%d\r\n",newchr.major , newchr.minor);
  
  	//字符串设备初始化、注册添加到内核
  	newchr.cdev.owner = THIS_MODULE;
      // 内核函数，完成cdev结构体与设备操作函数集的绑定
      cdev_init(&newchr.cdev , &chrdevbase_fops);
      // 内核函数，将一个已经初始化好的cdev结构体添加到内核的字符设备子系统中
      cdev_add(&newchr.cdev , newchr.devid ,NEWCHR_LED_CNT);
  	//创建设备类
      /*
      class_create 函数用于在 /sys/class 目录下创建一个新的设备类目录，最终用户空间的 udev 或 mdev 守护进程根据这些信息在 /dev 目录下自动生成设备文件，完成设备节点的自动插入
      */
      newchr.class = class_create(THIS_MODULE , NEWCHR_NAME);
      if(IS_ERR(newchr.class))
      {
          return PTR_ERR(newchr.class);
      }
  	//创建类的实例化设备 ,dev下面创建文件
      newchr.device = device_create(newchr.class , NULL , newchr.devid ,NULL ,NEWCHR_NAME);
      if(IS_ERR(newchr.device))
      {
          return PTR_ERR(newchr.device);
      }
      return 0;
  }
  
  /* 驱动出口函数 */
  static void __exit chrdevbase_exit(void)
  {
  	//解除寄存器映射
  	iounmap(GPIO_TEST);
  	//删除cdev字符串设备
  	cdev_del(&newchr.cdev);
  	//释放设备号
      unregister_chrdev_region(newchr.devid , NEWCHR_CNT);
  	//具体设备注销
      device_destroy(newchr.class, newchr.devid);
      //类注销
      class_destroy(newchr.class);
  }
  
  /* 将上面两个函数指定为驱动的入口和出口函数 */
  module_init(chrdevbase_init);
  module_exit(chrdevbase_exit);
  
  MODULE_LICENSE("GPI");//GPL模块许可证
  MODULE_AUTHOR("songwei");//作者信息
  ```

* 驱动函数资源管理

  * Linux 系统是个多任务操作系统，存在多任务访问同一资源如临界资源，临界区(代码段)的情况
  * 并发可为多线程并发，多线程抢占，中断程序，多核并发四种情况
  * 共同访问如内存等资源可造成混乱，故须对共享数据进行相应的保护处理

  ```c
  // 为控制对共享资源的访问，可使用原子变量，自旋锁，信号量，互斥体
  
  // 原子变量: 同时只能能被一个进程访问
  atomic_t b = ATOMIC_INIT(0); //定义原子变量 b 并赋初值为 0
  /* 通过判断原子变量的值来检查LED有没有被别的应用使用，类似信号量 */
  if (!atomic_dec_and_test(&gpioled.lock)) 
  {
      atomic_inc(&gpioled.lock);	/* 小于0的话就加1,使其原子变量等于0 */
      return -EBUSY;				/* LED被使用，返回忙 */
  }
  
  // 自旋锁: 自旋锁正在被线程 A 持有，线程 B 想要获取自旋锁，那么线程 B 就会处于忙循环-旋转-等待状态
  spin_lock_irqsave(&gpioled.lock, flags);	/* 上锁 */
  if (gpioled.dev_stats) 
  {					/* 如果设备被使用了 */
      spin_unlock_irqrestore(&gpioled.lock, flags);/* 解锁 */
      return -EBUSY;
  }
  gpioled.dev_stats++;	/* 如果设备没有打开，那么就标记已经打开了 */
  spin_unlock_irqrestore(&gpioled.lock, flags);/* 解锁 */
  
  // 信号量: 进程会尝试获取信号量，信号量可用，进程继续执行；如果信号量不可用，进程就会等待 / 休眠
  // 信号量的值代表当前可用资源数量，其被使用时就会-1，释放时+1
  /* 尝试获取信号量，未能获取则进入休眠状态，但进程可以被信号打断 */
  if (down_interruptible(&gpioled.sem)) { 
      return -ERESTARTSYS;
  }
  /* 尝试获取信号量，未能获取则进入休眠状态，且进程不能被信号打断 */
  down(&gpioled.sem);		
  /* 释放信号量，信号量值加1 */
  up(&dev->sem);		
  
  // 互斥体struct mutex lock: 一次只有一个线程可以访问共享资源(等价于信号量值为1)
  /* 获取互斥体,可以被信号打断 */
  if (mutex_lock_interruptible(&gpioled.lock)) {
      return -ERESTARTSYS;
  }
  /* 不能被信号打断 */
  mutex_lock(&gpioled.lock);	
  /* 释放互斥锁 */
  mutex_unlock(&dev->lock);
  
  ```

* 设备控制接口ioctl: 当驱动函数不为默认操作如read，write时，统一通过ioctl函数 + 命令码 + 输入参数进行调用
  ```c
  /* 驱动层 */
  #include <sys/ioctl.h>
  
  #define MYDEVICE_SET_LED_STATE      _IOW(MYDEVICE_IOC_MAGIC, 1, int)
  #define MYDEVICE_GET_BUTTON_STATE   _IOR(MYDEVICE_IOC_MAGIC, 2, int)
  // 驱动程序的ioctl函数体中，实现了一个switch-case结构，每一个case对应一个命令码
  static long chrdevbase_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
  {
      ...
      // 根据不同的命令码执行对应的操作
      switch (cmd) {
          case MYDEVICE_SET_LED_STATE:
              ...
          case MYDEVICE_GET_BUTTON_STATE:
              ...
          default:
              ...
      }
  }
  
  /* 应用层 */
  #include <sys/ioctl.h>
  int ioctl(int fd, unsigned long request, (...)arg);
  ```


* 字符设备阻塞与非阻塞IO: read / write
  ```c
  /* 应用层实现 -- 检测一个按钮是否被按下 */
  // 阻塞式访问: 若当前设备无法使用，则程序会停止在read处并休眠，并等待驱动程序将其唤醒
  fd = open(filename, O_RDWR);
  if (fd < 0) 
  {
      printf("Can't open file %s\r\n", filename);
      return -1;
  }
  
  ret = read(fd, &data, sizeof(data));
  if (ret < 0) { /* 数据读取错误或者无效 */
      ......
  } else { /* 数据读取正确 */
      ......
  }
  
  // 非阻塞式访问 + 轮询：设备打开后立即进入 poll 检查逻辑；poll 会等待设备变为可读，超时时间为 500ms；
  // 可使用函数poll || epoll || select轮询，若设备可读，再通过 read() 读取数据。
  int ret;
  int fd; /* 要监视的文件描述符 */
  struct pollfd fds;
  
  fd = open(filename, O_RDWR | O_NONBLOCK); /* 非阻塞式访问 */
  
  fds.fd = fd; /* 构造结构体 */
  fds.events = POLLIN; /* 监视数据是否可以读取 */
  while (1) {
      ret = poll(&fds, 1, 500); /* 轮询文件是否可读（非阻塞），此处驱动的 poll 实现仅检测状态，不执行 read 操作，超时 500ms */
      if (ret) {/* 数据有效，读取数据 */
          ret = read(fd, &data, sizeof(data));
          ......
      } else if (ret == 0) { /* 超时 */
          ......
      } else if (ret < 0) {  /* 错误 */
          ......
      }
  }
  
  /* 驱动层实现 */
  
  // 阻塞式访问: 驱动程序使用等待队列(Wait Queue--双循环链表)来实现阻塞进程的唤醒
  // 等待队列头
  struct __wait_queue_head {
      spinlock_t lock; //自旋锁
      struct list_head task_list; //链表头
  };
  typedef struct __wait_queue_head wait_queue_head_t;
  // 等待队列项
  struct __wait_queue {
      unsigned int flags;
      void *private;
      wait_queue_func_t func;
      struct list_head task_list;
  };
  typedef struct __wait_queue wait_queue_t;
  
  // 非阻塞式访问: 内核驱动file_operations中poll便会被执行，用于轮询对应驱动资源
  // 当前场景下该函数用于检测按钮是否被按下
  static ssize_t imx6uirq_read(struct file *filp, char __user *buf,size_t cnt, loff_t *offt)
  {
      int ret = 0;
      unsigned char keyvalue = 0;
      unsigned char releasekey = 0;
      struct imx6uirq_dev *dev = (struct imx6uirq_dev *)filp->private_data;
  
      if (filp->f_flags & O_NONBLOCK)	/* 非阻塞访问 */
      { 
          if(atomic_read(&dev->releasekey) == 0)	/* 没有按键按下，返回-EAGAIN */
              return -EAGAIN;
      } 
      else /* 阻塞访问 */
      {							
          /* 加入等待队列，等待被唤醒,也就是有按键按下 */
          ret = wait_event_interruptible(dev->r_wait, atomic_read(&dev->releasekey)); 
          if (ret) 
          {
              goto wait_error;
          }
      }
      ......  
  wait_error:
  	return ret;
  	......
  /* 运行成功则清除&dev->releasekey状态
  read_success:
  	keyvalue = dev->keyvalue;
  	atomic_set(&dev->releasekey, 0);
  */
  }
  
  // 注册当前进程等待队列，同时检测设备状态
  // 如果设备当前已可读（被操作），返回 POLLIN | POLLRDNORM 表示可读
  unsigned int imx6uirq_poll(struct file *filp, struct poll_table_struct *wait)
  {
  	unsigned int mask = 0;
  	struct imx6uirq_dev *dev = (struct imx6uirq_dev *)filp->private_data;
  
  	poll_wait(filp, &dev->r_wait, wait);	/* 将等待队列头添加到poll_table中 */
  	
  	if(atomic_read(&dev->releasekey)) {		/* 按键按下 */
  		mask = POLLIN | POLLRDNORM;			/* 返回PLLIN */
  	}
  	return mask;
  }
  
  static struct file_operations imx6uirq_fops = 
  {
      ......
      .poll = imx6uirq_poll,
  };
  ```

* 异步通知机制(信号通知--内核与应用层间通讯方式，如ctrl + c)
  ```c
  /* 应用层 */
  
  static void sigio_signal_func(int signum)
  {
  	int err = 0;
  	unsigned int keyvalue = 0;
  
  	err = read(fd, &keyvalue, sizeof(keyvalue));
  	if(err < 0) {
  		/* 读取错误 */
  	} else {
  		printf("sigio signal! key value=%d\r\n", keyvalue);
  	}
  }
  
  int main(int argc, char *argv[])
  {
  	......
  	fd = open(filename, O_RDWR);
  
  	/* 设置接收 SIGIO 信号，并指定信号处理函数为 sigio_signal_func */
  	signal(SIGIO, sigio_signal_func);
  	// fcntl系统调用可以用来对已打开的文件描述符进行各种控制操作以改变已打开文件的的各种属性
  	fcntl(fd, F_SETOWN, getpid());		/* 设置当前进程为 fd 的属主，使驱动可向该进程发送 SIGIO 信号 	*/
  	flags = fcntl(fd, F_GETFL);			/* 获取文件状态标志 			*/
  	fcntl(fd, F_SETFL, flags | FASYNC);	/* 设置 FASYNC 标志，开启异步通知机制，驱动需实现 .fasync 文件操作 */	
  
  	while(1) {
  		sleep(2);
  	}
  
  	close(fd);
  	return 0;
  }
  
  /* 驱动层 */
  
  struct imx6uirq_dev{
  	......
  	struct fasync_struct *async_queue;		/* 异步通知所需的结构体 */
  };
  
  struct imx6uirq_dev imx6uirq;	/* irq设备 */
  
  // 后台定时器，当按键被触发时向用户进程发送信号
  void timer_function(struct timer_list *t)
  {
  	......
  	if(atomic_read(&dev->releasekey)) {		/* 一次完整的按键过程 */
  		if(dev->async_queue)
  			kill_fasync(&dev->async_queue, SIGIO, POLL_IN);	/* 发送SIGIO信号 */
  	}
  	......
  }
  
  // 用于异步通知结构体的初始化
  static int imx6uirq_fasync(int fd, struct file *filp, int on)
  
  {
  	struct imx6uirq_dev *dev = (struct imx6uirq_dev *)filp->private_data;
  	return fasync_helper(fd, filp, on, &dev->async_queue);  /* 初始化fasync_struct 结构体指针*/
  }
  
  // 关闭驱动程序(执行release)时要手动删除异步通知
  static int imx6uirq_release(struct inode *inode, struct file *filp)
  {
  	return imx6uirq_fasync(-1, filp, 0); /* 删除异步通知 */
  }
  
  /* 设备操作函数 */
  static struct file_operations imx6uirq_fops = {
  	......
  	.fasync = imx6uirq_fasync,
  	.release = imx6uirq_release,
  };
  ```

**Linux系统的驱动框架设计**

* 核心设计理念

  * 设备驱动的分层设计: 类似面向对象的基础类，同类的设备有基础框架， 框架中的核心层则实现了该设备通用的一些功能，如需修改则可重载功能。
  * 驱动的分离与分层: 将设备信息从设备驱动中剥离开来(DTS)，并使用标准方法获取设备信息。驱动(driver)只负责驱动，设备(device)只负责设备，总线(bus)法将两者进行匹配。
    <img src="https://cdn.jsdelivr.net/gh/laotianye01/img_bed@image/note_image/20542523748.png" alt="20542523748" style="zoom: 25%;" />

* platform_driver
  ```c
  // 表示一个平台驱动的结构体，包含了匹配、注册、卸载、挂起等回调函数指针
  struct platform_driver {
      // 提供对 device_driver 中基础回调函数的重写，用于平台总线匹配的处理
      int (*probe)(struct platform_device *);   // 驱动与设备匹配成功以后 probe 函数就会执行
      int (*remove)(struct platform_device *);  // 当驱动与设备解绑（例如卸载驱动模块或移除设备节点）时会调用该函数
      void (*shutdown)(struct platform_device *);
      int (*suspend)(struct platform_device *, pm_message_t state);
      int (*resume)(struct platform_device *);
      // platform_driver 通过包含 device_driver 实现类似于面向对象中的“继承”
      struct device_driver driver;
      const struct platform_device_id *id_table; // 表示该平台驱动支持的设备名称列表（用于非设备树匹配）
      bool prevent_deferred_probe;
  };
  
  struct platform_device_id {
      char name[PLATFORM_NAME_SIZE];
      kernel_ulong_t driver_data;
  };
  
  // inux 驱动模型的基础结构体，包含驱动名称、所属bus、device匹配回调等信息
  struct device_driver {
      const char *name;
      struct bus_type *bus;
   
      struct module *owner;
      const char *mod_name; /* used for built-in modules */
   
      bool suppress_bind_attrs; /* disables bind/unbind via sysfs */
   
      const struct of_device_id *of_match_table; // 指向设备树匹配表（of_device_id），用于与设备树节点进行匹配
      const struct acpi_device_id *acpi_match_table;
      int (*probe) (struct device *dev);
      int (*remove) (struct device *dev);
      void (*shutdown) (struct device *dev);
      int (*suspend) (struct device *dev, pm_message_t state);
      int (*resume) (struct device *dev);
      const struct attribute_group **groups;
      const struct dev_pm_ops *pm;
      struct driver_private *p;
  };
  
  // 设备树匹配表结构体，用于驱动与设备树节点通过 compatible 等字段匹配
  struct of_device_id {
      char name[32];
      char type[32];
      char compatible[128];
      const void *data;
  };
  ```

  

* platform_device: 定义device的名称、资源、设备信息等，其可由操作系统内核通过设备树解析出来
  ```c
  // 如内核支持设备树则不需要定义以下内容
  
  struct platform_device {
      const char *name;
      int id;
      bool id_auto;
      struct device dev;
      u32 num_resources;
      struct resource *resource; // 指向资源数组，描述所需的内存、中断等信息
   
      const struct platform_device_id *id_entry;
      char *driver_override; /* Driver name to force a match */
   
      /* MFD cell pointer */
      struct mfd_cell *mfd_cell;
   
      /* arch specific additions */
      struct pdev_archdata archdata;
  };
  
  // 表示设备所需的硬件资源，如内存、IO端口、中断等
  // resource为内存时，start与end表明其将使用内存的起始与结束物理地址
  struct resource {
      resource_size_t start;
      resource_size_t end;
      const char *name;
      unsigned long flags;
      struct resource *parent, *sibling, *child;
  };
  ```

* platform_bus: 用于匹配与管理设备(platform_device)与驱动(platform_driver)
  ```c
  struct bus_type {
      const char *name; /* 总线名字 */
      const char *dev_name;
      struct device *dev_root;
      struct device_attribute *dev_attrs;
      const struct attribute_group **bus_groups; /* 总线属性 */
      const struct attribute_group **dev_groups; /* 设备属性 */
      const struct attribute_group **drv_groups; /* 驱动属性 */
   
      // match根据注册的设备来查找对应的驱动，或者根据注册的驱动来查找相应的设备
      int (*match)(struct device *dev, struct device_driver *drv); 
      int (*uevent)(struct device *dev, struct kobj_uevent_env *env);
      int (*probe)(struct device *dev);
      int (*remove)(struct device *dev);
      void (*shutdown)(struct device *dev);
   
      int (*online)(struct device *dev);
      int (*offline)(struct device *dev);
      int (*suspend)(struct device *dev, pm_message_t state);
      int (*resume)(struct device *dev);
      const struct dev_pm_ops *pm;
      const struct iommu_ops *iommu_ops;
      struct subsys_private *p;
      struct lock_class_key lock_key;
  };
  
  ```

* 如何添加一个设备驱动

  * 添加`.dts`节点(旧版为创建`device.c`): 定义设备的硬件信息，如寄存器地址，中断号，对应驱动与总线等
  * 创建driver.c: 实现并注册 platform_driver，包含 probe 和 remove 函数(用以在bus匹配到设备后启动 / 移除驱动程序) && 如需与用户空间通讯，实现 file_operations 接口(驱动函数如read，write)



### 操作系统搭建

* 自制操作系统资料

  1. [30days OS code in Chinese](https://github.com/yourtion/30dayMakeOS)
  2. [ebook](https://github.com/KnightCpp/The-C-Book/blob/master/%5B30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%5D.(%E5%B7%9D%E5%90%88%E7%A7%80%E5%AE%9E).%E5%91%A8%E8%87%AA%E6%81%92%E7%AD%89.%E6%89%AB%E6%8F%8F%E7%89%88.pdf)
  3. [original iso file--tool && source code](https://github.com/sky5454/30daysMakeOS-Origin-ISOfiles)

* 操作系统: 操作系统需通过进程调度等机制，让多进程在有限硬件（涉及硬件管理）上良好并发，进程切换是实现该目标的关键环节，其核心涉及上下文切换机制（内存存储管理），中断常作为触发切换的重要条件，同时结合调度算法等，共同保障多任务高效运行

  ![image-20250719125238707](https://cdn.jsdelivr.net/gh/laotianye01/img_bed@image/note_image/image-20250719125238707.png)

* 操作系统的启动

  1. 上电后，CPU 会首先执行主板上 ROM (只读存储器) 中的 BIOS (Basic Input/Output System) 程序，BIOS/UEFI 会进行一系列的上电自检 (Power-On Self-Test, POST)，检测并初始化计算机的基本硬件，如内存、显卡、键盘、硬盘控制器、USB 控制器等
  2. BIOS/UEFI 会根据你在 BIOS/UEFI 设置中配置的启动顺序(Boot Order)寻找可引导设备(第一扇区可引导的存储设备，硬盘/软盘/U盘)，并将将可引导设备的第一扇区中的代码(引导加载程序--IPL/(initial program loader)bootloader)加载到内存当中。
  3. BIOS/UEFI 会将这个引导扇区的内容加载到内存中的特定地址(通常是 `0x7c00`)，然后将控制权交给这段代码。在此之后，CPU 就会开始执行这段代码。

* 复杂执行流(gcc编译)，适用于函数(栈位于内存，用于存储执行流相关的临时变量)

  ```assembly
  ;void test() {
  ;;;1. 开辟栈帧(非必须)
  00B51380  push        ebp
  00B51381  mov         ebp,esp
  00B51383  sub         esp,0CCh
  ;;;2. 保存上下文(非必须)
  00B51389  push        ebx
  00B5138A  push        esi
  00B5138B  push        edi
  ;;;3. 初始化开辟的栈空间(非必须)
  00B5138C  lea         edi,[ebp-0CCh]
  00B51392  mov         ecx,33h
  00B51397  mov         eax,0CCCCCCCCh
  00B5139C  rep stos    dword ptr es:[edi]
  ;;;4. 业务逻辑
      ;int a = 0;
  00B5139E  mov         dword ptr [a],0
  ;}
  ;;;5. 恢复上下文(非必须)
  00B513A5  pop         edi
  00B513A6  pop         esi
  00B513A7  pop         ebx
  ;;;6.释放栈(非必须)
  00B513A8  mov         esp,ebp
  00B513AA  pop         ebp
  00B513AB  ret
  ```



**linux**

* 中断机制

  * 定义: CPU 在执行程序的过程中为了应对突发事件，其必须能暂停当前程序的执行转去处理突发事件，并在处理完后切换回来

  * 场景: 以触摸屏为例，触摸屏通过中断输出引脚发出电信号。在系统启动时，触摸屏的设备驱动程序会依据设备树中描述的硬件连接信息（例如中断引脚连接到哪个GPIO）获取到对应的逻辑中断号 (IRQ)，随后，该驱动程序会向 Linux 内核注册其特定的中断处理函数 (ISR)，将ISR与IRQ相关联。运行时当触摸屏被触发是，GPIO 控制器和中断控制器硬件会检测到这个电信号，并将其转化为一个逻辑中断请求 (IRQ)。Linux 操作系统（内核）会根据中断向量表查找对应的中断处理函数

  * 硬件驱动配置: 在DTS文件中描述中断的类型和连接方式，并在驱动驱动程序中给出对应的中断处理函数
    ```c
    /* Soc系统级中断控制器 */
    
    // 定义ARM 通用中断控制器 (GIC)，所有中断信号最终的控制者
    intc:interrupt-controller @00a01000
    {
        compatible = "arm,cortex-a7-gic";
        #interrupt - cells = < 3>;
        interrupt - controller;
        reg = <0x00a01000 0x1000>,
        <0x00a02000 0x100>;
    };
     
    // 定义了GPIO控制器，定义了两种中断，且定义其中断信号将转交到interrupt-controller
    gpio5 : gpio @020ac000{
        compatible = "fsl,imx6ul-gpio", "fsl,imx35-gpio";
        reg = <0x020ac000 0x4000>;
        interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>, 
                     <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
        gpio-controller;
        #gpio-cells = <2>;
        interrupt-controller;
        #interrupt-cells = <2>;
    };
    
    /* GPIO驱动部分代码 */
    // 定义 tasklet
    struct tasklet_struct testtasklet;
    
    // tasklet 处理函数 (下半部)
    void testtasklet_func(unsigned long data)
    {
        // 在这里执行耗时较长、可以延后的中断下半部处理
        // data 参数可以传递具体的GPIO引脚号或其他事件相关信息
        printk(KERN_INFO "Tasklet: 处理了 GPIO 引脚 %lu 的事件。\n", data);
    }
    
    // GPIO控制器自身中断处理函数（上半部--需快速执行）
    // 这是处理 interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH> 的中断函数
    static irqreturn_t imx_gpio_irq_handler_74(int irq, void *dev_id)
    {
        struct imx_gpio_data *gpio_data = (struct imx_gpio_data *)dev_id;
        u32 irq_status; // 用于存储GPIO中断状态寄存器的值
        // 1. **核心逻辑**: 读取GPIO中断状态寄存器并清除中断标志
        // 实际应从 gpio_data->reg_base + GPIO_ISR_REG 读取
        irq_status = readl(gpio_data->reg_base + GPIO_ISR_REG);
        // 实际应写入 gpio_data->reg_base + GPIO_ISR_REG 清除中断
        writel(irq_status, gpio_data->reg_base + GPIO_ISR_REG);
    
        dev_dbg(gpio_data->dev, "GPIO IRQ 74 received!\n");
    
        // 如果GPIO控制器作为中断控制器，这里会进一步处理子中断（例如，通知连接到GPIO引脚的按键驱动）
        // 伪代码：处理下级中断域的级联中断
        // handle_nested_irq(gpio_data->irq_domain, irq_status);
        // 使用tasklet来处理更复杂的GPIO引脚中断事件
        if (irq_status & (1 << gpio_pin)) {
            tasklet_schedule(&testtasklet);
        }
    
        return IRQ_HANDLED; // 表明中断已处理
    }
        
    // 驱动入口函数
    static int __init xxxx_init(void)
    {
        ......
        // 初始化 testtasklet 结构体中指针指向对应函数
        tasklet_init(&testtasklet, testtasklet_func, data);
     
        // 注册中断处理函数
        request_irq(xxx_irq, test_handler, 0, "xxx", &xxx_dev);
        ......
    }
    ```

    * 中断处理函数需要能快速执行以降低系统中断时间，所以其被拆分为上(快速执行的核心逻辑)下(可能执行的复杂逻辑)两部分，下部分中断可由三种方式执行: 软中断 / tasklet(通过软中断实现，但更为灵活，不能休眠) / 工作队列(可休眠--处理最为复杂的情况)

* 中断机制运行流程(arm)

  * 相关名词

    1. IRQ (interrupt request): 中断请求
    2. ISR (interrupt service routine): 中断处理函数
    3. IVT (Interrupt Vector Table): 中断向量表(用于用于匹配中断请求与中断处理函数)

  * 处理流程

    1. 中断请求(IRQ)发生，寄存器状态改变

       * (register value) LR --> 指向返回地址由当前成勋运行状态决定 (handle / thread && MSP / PSP)
         <img src="https://s2.loli.net/2024/06/11/K2hj9aRiJBYmIlf.png" alt="image-20240611163629852" style="zoom: 50%;" />
       * (register value) PC寄存器指向ISR函数地址 (错误处理函数(ISR)地址通过IRQ类型对照IVT得到具体的地址)
       * (register value) MSP / PSP寄存器更新，新的地址为压入register之后情况 (每次均+4后压入新的register值，总共压入8个register值)
       * (state)Mode: from (Handler / Thread) --> Handler (中断处理使用Handler)
       * (state)Stack: from (MSP / PSP) --> MSP (中断处理使用MSP mode，不管之前的运行模式是什么，寄存器数据的保存与恢复均会在MSP寄存器中进行)

    2. 保存当前进程状态与上下文到栈 (context includes: PC, r0-r3, r12, LR/r14,  xPSR (program state register) ), save to which SP (Main (MSP) \ process (PSP)) depends on operation mode
       <img src="https://s2.loli.net/2024/06/11/l9JfHSE6dYv3aMk.png" alt="image-20240611161730243" style="zoom: 50%;" />

       ![image-20240617144801464](https://s2.loli.net/2024/06/17/NfrGYB9FkqDcxQl.png)

    3. using IVT to determine ISR (产生的IQR可依据IVT表找到对应的ISR来处理其产生的问题)

* 内存管理系统

  * 核心: CPU只能访问虚拟地址，不能直接向设备寄存器地址写入数据，故其需要通过MMU得到寄存器物理地址在Linux系统中对应的虚拟地址

  * MMU(Memory Manage Unit)--硬件: 实现了虚拟地址与物理地址的映射(`ioremap()`物理->虚拟 && `iounmap()`虚拟->物理)，其地址上限为cpu虚拟地址总线宽度(一般小于cpu位数)。

    <img src="https://cdn.jsdelivr.net/gh/laotianye01/img_bed@image/note_image/image-20250721150358896.png" alt="image-20250721150358896" style="zoom: 33%;" />

    1. CPU生成访问的虚拟地址(硬件)，操作系统维护每个进程虚拟地址与物理地址的映射关系页表，并将对应将物理页帧的地址写入到页表中对应虚拟页的条目中(软件)
    2. MMU结合当前进程页表进行地址转换(硬件)，使用TLB(Translation Lookaside Buffer)缓存进行寻址加速(硬件)
    3. MMU将物理地址发送给内存控制器后内存控制器读取对应RAM并返回数据(硬件)

  * 内存管理器核心数据结构 -- 页表(操作系统管理虚拟/物理地址映射的数据结构)
    <img src="https://cdn.jsdelivr.net/gh/laotianye01/img_bed@image/note_image/image-20250721153239818.png" alt="image-20250721153239818" style="zoom:50%;" />

    * 二级页表，页目录号找到下一级页表物理基地址，页号找到页中存储物理页帧基地址，在物理页中通过offset偏移量找到具体数据

* 综合说明操作系统的职能与特性: 假设有两个main函数启动的进程A && B在一个单核计算机上运行
  -> 操作系统说明: 操作系统内核的许多核心功能并不是通过主动轮询的线程来实现的，而是基于**事件驱动**机制，在特定事件发生时被动唤醒并响应处理。操作系统内核可以按照功能划分为多个子系统，例如进程管理、内存管理、文件管理和设备管理等。每个子系统包含一系列用于处理相关任务的函数，这些函数通过**系统调用（软中断）**、**硬件中断（硬中断）**或**异常**被触发执行。系统通过**中断向量表**来保存这些事件对应的处理程序入口地址，从而实现快速响应和调度。

  ```c
  /*
  模拟程序伪代码
  */
  void main(int argc, char *argv[]) {
      char* str_a = "Hello from Program: " + argv[0]);
      int lcd_fd = open("/dev/lcd_display", O_WRONLY);
      int cont = 0;
      while (1) {
          cont++;
          if (write(lcd_fd, str_a, strlen(str_a)) < 0 || cont > 1000) {
              cont = 0;
              sleep(1);
          }
      }
  }
  
  /*
  模拟LCD显示器驱动伪代码
  */
  
  // 假设led设备上存在cache，其有一个硬件地址与对应的大小
  #define LCD_PHY_ADDR (0x01234567)
  #define LCD_SIZE     (100) // 假设LCD缓冲区大小
  ...
  
  // LCD设备结构体，用以管理设备相关的信息与资源
  struct lcd_dev {
      void __iomem *virt_addr;
      struct mutex lock;
  };
  
  // 全局设备实例，由驱动程序初始化和管理。
  // 各个驱动函数通过它来访问和操作LCD硬件。
  static struct lcd_dev *g_lcd_dev;
  
  // linux中设备向用户的接口为文件，open造作将设备结构体指针保存到设备接口文件(结构体)的私有数据中
  // linux系统所有打开的文件都有对应的文件描述符，在用户空间中为一个int值，用户可通过系统调用+文件描述符定位到一个具体文件
  static int lcd_open(struct inode *inode, struct file *filp) {
      filp->private_data = g_lcd_dev; 
      return 0; // 成功返回0
  }
  
  // LCD write系统调用对应函数
  static void lcd_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos) {
      struct lcd_dev *dev = (struct lcd_dev *)filp->private_data;
      char *kbuf;
      kbuf = kmalloc(count, GFP_KERNEL);
      // 操作系统的用户内存空间与内核内存空间是隔离的(保证内核内存安全)
      // 用户级的内存都是虚拟地址，其通过页表+MMU转化为物理地址；而内核级则可访问物理地址上信息
      // 内核级无法直接访问用户级的虚拟地址，所以其需要将对应信息复制到内核所能调用的内存当中
      copy_from_user(kbuf, buf, count);
      ssize_t ret_val;
  
      // 获取互斥锁：确保同一时间只有一个进程能操作LCD硬件
      if (mutex_lock_interruptible(&dev->lock)) {
          ret_val = -ERESTARTSYS; // 被信号打断
          goto free_kbuf_only;
      }
  
      // 将数据从内核临时缓冲区写入LCD设备的内存映射区域（LCD缓存--假设lcd会显示cache中内容）
      memcpy_toio(dev->virt_addr, kbuf, count);
      ret_val = count; 
      mutex_unlock(&dev->lock);
  
  // cpp中的标签，类似于汇编语言的标签，可使用goto进行跳转
  free_kbuf_only: // 错误处理和正常返回前都需要释放kbuf
      kfree(kbuf);
      return ret_val;
  }
  
  // file_operations 结构体，将系统调用与驱动函数关联起来
  static const struct file_operations lcd_fops = {
      .owner = THIS_MODULE,
      .open = lcd_open,
      .write = lcd_write,
      // ... 其他操作如 read, release
  };
  
  // linux操作系统会在内核启动时初始化注册的驱动设备
  // 操作系统会通过DTS初始化cdev树形结构，用以描述硬件信息与属性
  // 其同时会自动执行设备的init驱动，在dev下创建对应设备的用户接口文件
  static int __init lcd_driver_init(void) {
      int ret;
  
      // 字符设备注册
      // cpu无法直接访问设备上寄存器或cache，其需要通过内存映射将LCD硬件上寄存器映射到内存当中
      g_lcd_dev->virt_addr = ioremap(LCD_PHY_ADDR, LCD_SIZE);
      return 0;
  }
  ```

  * 计算机启动
    1. bios程序检查初始硬件，从可引导存储设备将首扇区的bootloader加载至内存，BIOS/UEFI程序将控制权（即CPU的执行流程）转交给bootloader
    2. cpu执行bootloader上程序加载操作系统内核，并执行内核的初始化代码。这些初始化代码会设置并填充中断描述符表（IDT）、初始化进程管理、内存管理、文件管理、设备管理等核心子系统的数据结构和状态。

  * 用户进程A与进程B
    1. 系统调用: 户在用户态通过 shell 执行程序 A 时，通常会先通过系统调用 `fork()` 创建子进程(复制代码空间，创建PCB并切换上下文，此处不详细展开)，并在子进程中调用 `execve()`。该系统调用通过 `svc` 指令触发软中断，CPU 根据异常向量表跳转至统一的系统调用入口函数，并切换至内核态。在入口函数中，系统保存用户态上下文，并根据系统调用号从系统调用表中找到并调用 `sys_execve`。该函数加载可执行文件 A，替换当前进程的用户空间映射，并更新 PCB 的相关字段。完成后，内核将 PC 设置为程序 A 的入口地址，并通过异常返回指令恢复用户态，开始执行新程序。
       当进程调用系统调用时，我们可以认为系统正在运行当前进程(进程代码空间和 PCB 保持不变)，只不过 CPU 的执行模式从用户态切换到了内核态。
    2. 硬中断: 当A进程正在被执行时，使用鼠标点击shell，该操作会触发硬件中断，CPU自动保存部分上下文，并通过中断向量表(IVT)跳转至中断服务例程 (ISR)。如果 ISR 检测到有新的事件使其他进程（如 shell）变为可运行状态，它可能触发调度器执行，调度器会依据调度原则(如优先级、时间片轮转)调度已就绪的进程，并加载已就绪的进程上下文信息(如使pc指向原shell进程对应代码，将寄存器指向原代码空间)
    3. 进程A执行: A进程使用统一字符设备系统调用open调用了其对应驱动程序lcd_open(简化描述)，该操作使file结构体`/dev/lcd`的私有空间指向了设备实例，同时该file结构体可以在用户空间通过文件描述符(int)进行访问。在用户进程获取驱动的文件描述符后，其调用write系统调用跳转到系统调用入口函数，使当前进程由用户态变为内核态，并调用对应驱动程序lcd_write。为保证lcd同时只能被一个进程控制，lcd_write驱动首先会申请设备的互斥锁，在此之后其会将用户空间字符内容复制到内核空间，并调用特定函数将其复制到lcd自身的cache中以显示对应信息。
    4. 启动进程B: 忽略输入，shell等流程，并假设A进程刚获取了dev->lock。当shell已创建出子进程并在其中调用`execve()`启动进程B时，当B运行到write系统调用，并执行lcd驱动函数lcd_write时，`mutex_lock_interruptible`函数无法获取互斥锁，其会将B进程放置于互斥锁的等待队列中，并启动调度器。调度器会保存B进程的上下文，并依据调度策略启动选择一个就绪状态的进程来运行(加载其上下文)。当A进程执行`mutex_unlock(&dev->lock)`释放互斥锁时，其会唤醒等待序列中的一个或多个进程(此处为B)，B的状态则会从等待状态变为就绪状态，等待下一次调度器被触发后的调度操作。







### Linux视频驱动开发



* 核心: 在jetson系统中使用开发板的mipi接口与FPGA实现通信

* 参考教程

  1. [中文教程](https://nu-ll.github.io/2022/03/15/JetsonNano%E6%91%84%E5%83%8F%E5%A4%B4%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/)
  2. [Jetson官方开发教程](https://docs.nvidia.com/jetson/archives/r36.3/DeveloperGuide/SD/CameraDevelopment/SensorSoftwareDriverProgramming.html)
  3. [jetson官方开发包](https://developer.nvidia.com/embedded/jetson-linux)
  4. [linux driver developer](https://docs.kernel.org/driver-api/index.html#general-information-for-driver-authors)

* 视频有关媒体驱动层次
  
  * v4l2_dev: linux下视频设备，一般为视频输入输出数据线(mipi)，或是视频处理单元
  * v4l2_subdev: 连接在系统上的视频传感器，可按照数据线类型(i2c / spi)进行分类
  
* [Jetson官方开发教程](https://docs.nvidia.com/jetson/archives/r36.3/DeveloperGuide/SD/CameraDevelopment/SensorSoftwareDriverProgramming.html) -- 使用方法二:
  ![image-20250720165740339](https://cdn.jsdelivr.net/gh/laotianye01/img_bed@image/note_image/image-20250720165740339.png)

  
