# DBMS

### <font color=red>basic knowledge</font>!!

1. relation: a chart consisted of many row and columns 
2. Relational database: a collection of normalized relation with distinct relation name. 
3. tuple: a row in the relation
4. attribute: the named column of a relation
5. Degree: the number of attribute in the relation
6. Cardinality: the number of tuples in the relation
7. Domain: the set of allowable value for one or more attributes
8. integrity constrain:
   * null: the non-known value or a value will be set in the future will be given a null
   * entity constrain: no primary key can be null
   * Referential Integrity: a foreign key's value either match a candidate key in another relation or its value should be null
   * General Constraints: user's self defined constrain
9. key:
   * candidate key: one or a set of attributes witch can uniquely identify a tuple in a relation
   * primary key: selected candidate key to identify tuple in a relation
   * **foreign key**: (set of) attributes have relation with another relations candidate keys
   * composite key: candidate key consisted of set of attributes 

## Learning Outcomes

* Be able to explain the terminology of relational model

* Understand how tables are used to represent data.
* Be able to explain properties of database relations.
* Be able to identify candidate, primary, alternate, and foreign keys
* Understand and be able to explain entity integrity and referential integrity
* Be able to formulate queries in relational algebra.

## 1.basic information:

* DBMS: A software system that enables users to define, create, maintain, and control access to the database 

1. consist: **entity**, **attribution**, **relationship**
   * **entity**: object represented in database
   * **attribution**: property of object
   * **relationship**: association between entity
2. **data model**: representation of object + association
3. **scheme**: description of database
4. **DDL**: data definition language
5. **DML**: Data manipulation language
6. Three level ANSI-SPARC architecture:
   * Users’ views should be unaffected by changes to the physical aspects of storage.
   * Internal structure of the database should be unaffected by changes to the physical aspects of storage.
   * The DBA should be able to change the conceptual structure of the database with minimum affect to users’ views.

![微信图片_20230612105800](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230612105800.jpg)

* advantage/disadvantage:
  1. adv: (easy to manage/saving space/improve function)
     * Control of data redundancy
     * Data consistency
     *  More information from the same amount of data
     * Sharing of data
     * Improved data integrity
     * Improved security
     * Economy of scale
     * Balance conflicting requirements...
  2. dis:
     * Complexity
     * Size
     * Cost of DBMS
     * Additional hardware costs
     * Cost of conversion...

## 2.relation model:

1. **relation**: table with columns and rows.
2. **attribute**: named column of a relation.
3. **domain**: the set of allowable value for one or more attributes.
4. **tuple**: row of a relation.
5. **degree**: number of attributes in a relation.
6. **cardinality**: number of tuples in a relation.
7. **relation database**: a collection of normalized relations with distinct relation names.

![微信图片_20230612111358](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230612111358.jpg)

### relational keys:

* **candidate key**: a set of attributes that uniquely identifies a tuple within a relation.(no proper subset of it can be candidate key)
* **primary key**:.candidate key selected to identify unique tuples within relation
* **foreign key**: (set of)attribute within one relation that matches candidate key of some other relation.
* composite key: candidate key that consists of two or more attributes.
* example of a relation(same as the figure above): 
  1. Branch(<u>branchNo</u>, street, city, postcode) ->underline primary key
  2. Staff(<u>staffNo</u>, f-Name, l-Name, position, sex, DOB, salary, branchNo)
* Integrity Constraints: 
  1. **null**: don't have value/not know
  2. **Entity Integrity**: primary key can not be null.
  3. **Referential Integrity**: if foreign exist in a relation,either foreign key value must match a candidate key value of some tuple/value must be null
  4. General Constraints: specific constraints(define by manager) on values;

# Relational Algebra

![review P1](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/review P1.png)

![review P2](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/review P2.png)

![review P3](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/review P3.png)

![review P4](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/review P4.png)

![review P5](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/review P5.png)

![review P6](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/review P6.png)

![review P7](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/review P7.png)

![review P8](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/review P8.jpg)

# ER modelling

### <font color=red>basic knowledge</font>!!

* database: a shared collection of logically related data designed to meet the requirement of costumer.
* data model: graphical description of the components of database
* relational database: a collection of relation
* Entity-relationship (E-R) modelling: high-level conceptual modelling of a DB
* Entity: group of object with same property(basic building block of DB)
* Relationship: linkage between different two entities
* structure constrain: Cardinality(max value for relation occurrence); Participation(min value for relation occurrence)



1. Relationship: relate entity to entity
2. ER: Entity-relationship
3. building a database is an iterative process.

![review P9](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/review P9.png)

![review P10](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/review P10.png)

![review P11](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/review P11.png)

![review P12](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/review P12.png)

![review P13](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/review P13.png)

* data modelling

1. goal: identify the facts to be stored in a database
2. quality: 
   * A well-formed data model(Construction rules obeyed & No ambiguity)
   * A high fidelity image

* Making assumptions(different assumption leads to different result)

![review P14](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/review P14.png)

## EER

### <font color=red>basic knowledge</font>!!

* Superclass: a entity include one of more subgrouping of its occurrence
* subclass: distinct subgrouping occurrence
* Participation constraint: 
  * mandatory / optional
  * disjoint / nondisjoint(at most one / many)



1. definition: Enhanced Entity-Relationship 
2. inherence:
   * Superclass: includes one or more distinct subgroupings of its occurrences
   * Subclass: A distinct subgrouping of occurrences
3. constrains:
   *  participation constraints: Determines whether every member in superclass must participate as a member of a subclass.(***mandatory*** or ***optional***)
   * disjoint constraints: indicates whether member of a superclass can be a member of one, or more than one, subclass.(***disjoint(父类仅可为其中一个)*** or ***nondisjoint(父类可为其多个)***)
4. four type:
   * mandatory & or (disjoint)
   * optional & or (disjoint)
   * mandatory & and (nondisjoint)
   * optional & and (nondisjoint.)

![微信图片_20230612195644](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230612195644.png)

## Database Design Methodology

### <font color=red>basic knowledge</font>!!

* four steps: 
  * gather requirement
  * conceptual database design
  * logical database design
  * physical database design
* three level ANSI-SPARC architecture
  * external level(view)
  * conceptual level(conceptual scheme)
  * internal level(internal scheme)
  * physical data organization(database)

# SQL

### <font color=red>basic knowledge</font>!!

* SQL: transform-oriented language

# Data manipulation language (DML)

1. UPDATE(**UPDATE, SET**)

```
Q: Give all staff a 3% pay increase.

UPDATE Staff
SET salary = salary*1.03;

Q: Give all Managers a 5% pay increase.

UPDATE Staff
SET salary = salary*1.05
WHERE position = ‘Manager’;

Q: Promote David Ford (staffNo=‘SG14’) to Manager and change his salary to £18,000.

UPDATE Staff
SET position = ‘Manager’, salary = 18000
WHERE staffNo = ‘SG14’;
```

2. DELETE(**DELETE FROM**)

```
Q: Delete all viewings that relate to property PG4.

DELETE FROM Viewing
WHERE propertyNo = ‘PG4’;

Q: Delete all records from the Viewing table.

DELETE FROM Viewing;
```

3. INSERT(**INSERT INTO** ... **VALUES**)

```
Q: Insert a new row into Staff table supplying data for all mandatory columns.

INSERT INTO Staff (staffNo, fName, lName, position, salary, branchNo)
VALUES (‘SG44’, ‘Anne’, ‘Jones’, ‘Assistant’, 8100, ‘B003’);
// defult way
INSERT INTO Staff
VALUES (‘SG44’, ‘Anne’, ‘Jones’, ‘Assistant’, NULL, NULL, 8100, ‘B003’);

Q: The DATE type in MySQL follows the 'YYYY-MM-DD' format.The supported range is '1000-01-01' to '9999-12-31'

INSERT INTO Staff
VALUES ('SL21', 'John', 'White', 'Manager', 'M',
'1945-10-01', 30000, 'B005');
```

4. table:

```
//CREATE TABLE table_name
( { column_name data_type
[ DEFAULT default_expr ] [
column_constraint [, ... ] ] }
|table_constraint } [, ... ] )

//Drop table
DROP [TEMPORARY] TABLE [IF EXISTS]
```





## Data definition language (DDL)

### select

1. basic(**select, From, ***, **distinct**(去重)) 

```
Q: List full details of all staff.

SELECT staffNo, fName, lName, address,position, sex, DOB, salary, branchNo
FROM Staff;

// use * as all columns
SELECT * FROM Staff;

// show some column
SELECT staffNo, fName, lName, salary
FROM Staff;

// show distinct value
SELECT DISTINCT propertyNo
FROM Viewing;
```

2. with culculattion(**as**(重命名))

```
Q: Produce list of monthly salaries for all staff,showing staff number, first/last name, and salary.

SELECT staffNo, fName, lName, salary/12
FROM Staff;

Q: To name column, use AS clause

SELECT staffNo, fName, lName, salary/12 AS monthlySalary
FROM Staff;
```

3. Comparison Search Condition(**where**, **or, and**)

```
Q: List all staff with a salary greater than 10,000.

SELECT staffNo, fName, lName, position,salary
FROM Staff
WHERE salary > 10000;

Q: List addresses of all branch offices in London or Glasgow

SELECT * FROM Branch
WHERE city = “London” OR city = “Glasgow”; // 字符串双引号
```

4. range search(**between, and**)

```
Q: List all staff with a salary between 20,000 and 30,000.

SELECT staffNo, fName, lName, position, salary
FROM Staff
WHERE salary BETWEEN 20000 AND 30000;
```

5. Pattern Matching(**like, %(代替多个任意字符), _(代替一个任意字符)**)

```
Q: Find all owners whose address is in Glasgow.(Find all owners with the string ‘Glasgow’ in their address.)

SELECT ownerNo, fName, lName, address, telNo
FROM PrivateOwner
WHERE address LIKE “%Glasgow%”;
```

6. NULL Search Condition(**null**)

```
Q: List details of all viewings on property PG4where a comment has not been supplied

SELECT clientNo, viewDate
FROM Viewing
WHERE propertyNo = “PG4” AND comment IS NULL;
```

7. Single/multiple Column Ordering(**ORDER BY**: (**DESC(数值), attribute-name(name的字符)）**))

```
Q: Produce abbreviated list of properties in orderof property type and rent.

SELECT propertyNo, type, rooms, rent
FROM PropertyForRent
ORDER BY type, rent DESC;
```

8. SELECT Statement - Aggregates(**COUNT(*/distinct/attribute)->数满足条件tuple的个数, SUM(attribute), AVG(attribute), MIN(attribute), MAX(attribute)**)
   * DISTINCT has no effect with MIN/MAX, but may have with SUM/AVG

```
// Use of COUNT(*), count(distinct attribute)
Q: How many properties cost more than £350 per month to rent?

SELECT COUNT(*) AS myCount
FROM PropertyForRent
WHERE rent > 350;

// Use of COUNT(DISTINCT)
Q: How many different properties viewed in May ‘04?

SELECT
COUNT(DISTINCT propertyNo) AS myCount
FROM Viewing
WHERE viewDate BETWEEN “2004-05-01” AND “2004-05-31”;

// Use of COUNT and SUM
Q: Find number of Managers and sum of their salaries.

SELECT COUNT(staffNo) AS myCount,
SUM(salary) AS mySum
FROM Staff
WHERE position = “Manager”;

// Use of MIN, MAX, AVG
Q: Find minimum, maximum, and average staff salary

SELECT MIN(salary) AS myMin,MAX(salary) AS myMax,AVG(salary) AS myAvg
FROM Staff;
```

9. Grouping(**GROUP BY**(用于where的后面), **HAVING**(用于约束group条件: 对组进行条件筛选)) ->见原先的表进行分组，分组后每一部分再执行语句

```
Q: Find total number of staff in each branch and their total salaries

SELECT branchNo,COUNT(staffNo) AS myCount,SUM(salary) AS mySum
FROM Staff
GROUP BY branchNo
ORDER BY branchNo;

// having
Q: For each branch with more than 1 member of staff, find number of staff in each branch and sum of their salaries

SELECT branchNo,COUNT(staffNo) AS myCount,SUM(salary) AS mySum
FROM Staff
GROUP BY branchNo 
having COUNT(staffNo) > 1
ORDER BY branchNo;
```



* muti-table



1. Simple Join()->连接条件放于where中，一般为relation1.attributeX = relation2.attributeX

```
Q: List names of all clients who have viewed a property along with any comment supplied.

SELECT c.clientNo, fName, lName,propertyNo, comment
FROM Client c, Viewing v
WHERE c.clientNo = v.clientNo;
```

2. Sorting a join

```
Q: For each branch, list numbers and names of staff who manage properties, and properties they manage

SELECT s.branchNo, s.staffNo, fName,lName,propertyNo
FROM Staff s, PropertyForRent p
WHERE s.staffNo = p.staffNo
ORDER BY s.branchNo, s.staffNo,propertyNo;
```

3. Three Table Join

```
Q: For each branch, list staff who manage properties,including city in which branch is located and properties they manage

SELECT b.branchNo, b.city, s.staffNo, fName,lName,propertyNo
FROM Branch b, Staff s, PropertyForRent p
WHERE b.branchNo = s.branchNo AND
s.staffNo = p.staffNo
ORDER BY b.branchNo, s.staffNo, propertyNo;
```

4. Multiple Grouping Columns

```
Q: Find number of properties handled by each staff member

SELECT s.branchNo, s.staffNo, COUNT(*) AS myCount
FROM Staff s, PropertyForRent p
WHERE s.staffNo = p.staffNo
ORDER BY s.branchNo, s.staffNo;
```

5. **join, JOIN USING, JOIN ON, CROSS JOIN, LEFT JOIN, RIGHT JOIN, FULL JOIN **

```
// Client(Name, Cid, City)
// Meeting(Cid, City, Date)

// NATURAL JOIN – join on attributes with same name
SELECT * FROM
Client NATURAL JOIN Meeting;

// JOIN USING -> 指定连接的attribute
SELECT * FROM 
Client c JOIN Meeting m USING (Cid);

// JOIN ON (doesn’t combine column)->Cid不会合并
SELECT * FROM 
Client c JOIN Meeting m ON c.Cid=m.Cid;

// CROSS JOIN (Cartesian product)笛卡尔积
SELECT * FROM 
Students CROSS JOIN Courses;

// 表之间的连接位置决定那里可以取值为空
// LEFT JOIN
SELECT * FROM Client c
LEFT JOIN Meeting m ON c.Cid = m.Cid;

// RIGHT JOIN
SELECT * FROM Client c
RIGHT JOIN Meeting m ON c.Cid = m.Cid;

// FULL JOIN
SELECT * FROM Client c
FULL JOIN Meeting m ON c.Cid = m.Cid;
```



* Subqueries



1. Subquery with Equality(**select**语句返回搜索的结果)

```
Q: List staff who work in branch at ‘163 Main St’.

SELECT staffNo, fName, lName, position
FROM Staff
WHERE branchNo =
(SELECT branchNo
FROM Branch
WHERE street = ‘163 Main St’);
```

2. Subquery with Aggregate

```
Q: List all staff whose salary is greater than the average salary, and show by how much

SELECT staffNo, fName, lName, position,
salary - (SELECT AVG(salary) FROM Staff) As SalDiff
FROM Staff
WHERE salary > (SELECT AVG(salary) FROM Staff);
```

3. Nested subquery: (**IN** , **not in**->"="只能为一个值；"in"可在一个范围内)

```
Q: List properties handled by staff at ‘163 Main St’.

SELECT propertyNo, street, city, postcode, type, rooms, rent
FROM PropertyForRent
WHERE staffNo IN
(SELECT staffNo
FROM Staff
WHERE branchNo =
(SELECT branchNo
FROM Branch
WHERE street = “163 Main St”));
```

4. **ANY/SOME/ALL**->与in类似，为与一个集合的值进行比较

```
Q: Find staff whose salary is larger than salary of at least one member of staff at branch B003.

SELECT staffNo, fName, lName, position, salary
FROM Staff
WHERE salary > SOME (SELECT salary
FROM Staff
WHERE branchNo = ‘B003’);

Q: Find staff whose salary is larger than salary of every member of staff at branch B003.

SELECT staffNo, fName, lName, position, salary
FROM Staff
WHERE salary > ALL
(SELECT salary
FROM Staff
WHERE branchNo = ‘B003’); // 可用select max(salary) from staff实现
```

5. **EXISTS** and **NOT EXISTS**->与in类似

```
Q: Find all staff who work in a London branch

SELECT staffNo, fName, lName, position
FROM Staff s
WHERE EXISTS
(SELECT *
FROM Branch b
WHERE s.branchNo = b.branchNo
AND city = ‘London’);
```



# Normalization

### <font color=red>basic knowledge</font>!!

* suitable set of relations: 
  * minimal number of attributes
  * close logical relationship
  * minimal redundancy
* update anomalies: cause by data redundancy(insert delete)
* Decomposition: 
  * Lossless-join property:
  * Dependency preservation property
* Functional dependency: relation between attributes
* Full Functional Dependency: A -> B doesn't hold for any subset of A
* Partial functional dependency: A -> B still hold for a subset of A
* Transitive Dependencies: A -> B , B -> C, then A transitive depend on C
* UNF: a table contains repeating data
* 1NF: a relation whose row and column only contain one value
* 2NF: a relation is fully functional dependency
* 3NF: a 2NF relation without transitive dependency
* BCNF: a 3NF whose all A -> B,A is candidate key
* 4NF: a BCNF without muti-valued dependency
* muti-valued dependency: for each value a, there is a set of B and C, the set value of B and C are independent
* steps in normalization:
  * identify xx dependency
  * identify primary key
  * if exist, remove it from ~, put it in a new relation







## 1.Learning Outcomes

• Understand how **functional dependencies** identify the primary key for a relation.

• Understand how normalization uses functional dependencies to group attributes into relations that are in a known normal form.

• Be able to identify the most commonly used normal forms, namely First Normal Form (1NF), Second Normal Form (2NF), and Third Normal Form (3NF).

• Be able to decompose a relation to certain normal form.

# 2.basic information

1. Normalization is a technique for producing a suitable set of relations that support the data requirements of an enterprise.
2. suitable set of relations: 
   * **minimal** number of **attributes**
   * close logical relationship in the same relation
   * **minimal** **redundancy**

3.  Redundancy: lead to Update Anomalies

## 3.Functional Dependencies(FD)

### property

* Functional dependency describes relationship between attributes(ex: staffNo → s-Name)
* 定义: 一组关系模式中，所有关系内不存两组x的属性相同，而y属性不同，则称y函数依赖x(y → x)
* Full Functional Dependency: B is functionally dependent on A, but not on any proper subset of A(A不可更换为A的子集)
* Partial functional dependency: some attribute that can be removed from A and the dependency still holds.
* Transitive Dependencies: if A → B and B → C, then C is transitively dependent on A via B

### identify

1. ways

   * analysing the meaning of each attribute
   * provided by the enterprise
   * common sense

2. example1: 

   Examine semantics of attributes in Staff-Branch relation. Assume that position held and branch determine a member of staff’s salary. 

   ```
   staffNo -> sName, position, salary, branchNo, bAddress
   branchNo -> bAddress
   bAddress -> branchNo
   branchNo, position -> salary
   bAddress, position -> salary
   
   // Primary key: staffNo
   ```

3. exsanple2:

   ![微信图片_20230613150405](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613150405.png)

```
studentID -> projectID, sName, pName
projectID -> pName

// Primary key: studentID
```



## Normalization

### UNF

1. A table that contains one or more repeating groups.

![微信图片_20230613191812](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613191812.png)

### First Normal Form (1NF)

1. the intersection of each row and column contains one and only one value.

![微信图片_20230613191815](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613191815.png)

### Second Normal Form (2NF)

1. A relation that is in 1NF and every non primary-key attribute is **fully functionally dependent** on the primary key.

 ![微信图片_20230613193655](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613193655.jpg)

### Third Normal Form (3NF)

1. A relation that is in 1NF and 2NF and in which **no** non-primary-key attribute is **transitively dependent** on the primary key.

![微信图片_20230613193706](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613193706.jpg)

example:![微信图片_20230613195811](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613195811.jpg)

### Boyce–Codd Normal Form (BCNF)

1. A relation is in BCNF if and only if every determinant is a candidate key.(if exist functional dependency A -> B, A must be a candidate key. )

![微信图片_20230613193711](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613193711.jpg)

examples: 

![微信图片_20230613202200](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613202200.png)

![微信图片_20230613203325](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613203325.jpg)

### Fourth Normal Form (4NF)

1. Multi-valued Dependency (MVD): each value of A there is a set of values for B and a set of values for C. However, the set of values for B and C are independent of each other.(存在于全码中(即表中所有属性构成一个码), 将全码分解以得到4nf)
2. definition of MVD: A −>> B in relation R is defined as being trivial if (a) B is a subset of A *or* (b) A union B = R.
3. 多值依赖判断: 对于给定的一组A， B有多个相同的C与其相对

![微信图片_20230613204144](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613204144.jpg)

example: ![微信图片_20230613204814](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613204814.png)



## Denormalization

* when: 
  * Database speeds are unacceptable (not just a bit slow)
  * There are going to be very few INSERTs, UPDATEs, or DELETEs
  * There are going to be lots of SELECTs that involve the joining of tables



# Transaction Management

### <font color=red>basic knowledge</font>!!

* Transaction: a series of actions carried which read, update contents of database
* 4 basic property(ACID):
  * atomicity: "all or nothing"->transaction is run by block
  * consistency: from one valid state to anther
  * isolation: in a transaction, partial effect shouldn't be seen 
  * durability: effect of commit are permanent
* 3 problems:
  * Lost Update Problem: update of Ta is rewrite by Tb
  * Uncommitted Dependency Problem: Ta get a wrong value because Tb rollback
  * Inconsistent Analysis Problem: Ta read a wrong value because Tb modify it
* Schedule: sequency of operations by a set of concurrent
*  serial schedule: operation of each transaction executed serially
* Serialisability: find serial schedule equal to non-serial 
* Concurrency Control Techniques: locking, timestamping (timeout / DB check)
* lock: deny access to other transaction(read-lock;write-lock)->problems(cascading rollback+deadlock)
* timestamp: unique identifier indicator relative starting time of a transaction
* Recovery Facilities: backup mechanism, log file(information about updates), checkpoints(containing identifier of all active transaction)..



## 1.Learning Outcomes

1. Understand function and importance of transactions
2. Be able to explain ACID properties of transactions.
3. **Understand** and be able to **explain** the following for Concurrency Control
   * Meaning of serialisability.
   * How locking can ensure serialisability.
   * 2PL
   * Deadlock and how it can be resolved.
   * How timestamping can ensure serialisability. 
4. Be able to use 2PL to **rewrite** a transaction

## 1.Transaction

1. definition: Action, or series of actions, carried out by user or application, which reads or updates contents of database. 
2. Properties:
   * **A**tomicity
   * **C**onsistency 
   * **I**solation
   * **D**urability
3. example: ![微信图片_20230613210331](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613210331.png)
4. Success:  *commits*; failure: *rolled back*

## 3.Concurrency

1. property: don’t allow for concurrency->run sequentially
   * Have a queue of transactions 
   * make others wait for long periods

### Problems:

* **Lost Update Problem**(t2's update of x is lose)
* solution: preventing T1 from reading X until after the update.

![微信图片_20230613210919](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613210919.png)

* **Uncommitted Dependency Problem**(t3 get x, after that t4 roll back, t3 get a incorrect value)
* solution: preventing T3 from reading X until after T4 commits or aborts.

![微信图片_20230613211047](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613211047.png)

* **Inconsistent Analysis Problem**: (after t6 read the x for calculate sum, x value is change, which leads to the wrong value of sum)
* solution: preventing T6 from reading X (and Z) until after T5 completed updates

![微信图片_20230613211335](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613211335.png)



### Concurrency Control 

#### 1.Schedule

1. *serial schedule*: is a Schedule where operations of each transaction are executed consecutively without any interleaved operations from other transactions. 
2. **Serialisability**(任意初始状态，一个调度对数据库影响与某个串行调度相同)
3. Conflict Serialisability(一个调度可通过交换无冲突的两个事件得到某一串行调度)

![微信图片_20230613213126](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613213126.jpg)

1. Conflict(该两个事件不可交换顺序) situation:
   * two transactions only read a data item -> no conflict
   *  two transactions either read or write completely **separate data** items -> no conflict
   * one transaction writes a data item and another reads or writes **same data item** ->  conflict(R1(A) + W2(A) / W1(A) + R1(A) / W1(A) + W2(A))

![微信图片_20230613213308](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613213308.jpg)

### Techniques

1. way: Locking,Timestamping

#### Locking

1. function: deny access to other transactions and so prevent incorrect updates.

2. type:
   * Shared lock (read-lock): allows several transactions simultaneously to read a resource, but no transactions can change it at the same time
   * Exclusive lock (write-lock): allows **one** transaction exclusive access to write to a resource. other transaction **can not** read this resource at the same time.

3. **way to use**
   * Before reading from a resource a transaction must acquire a read-lock 
   * Before writing to a resource a transaction must acquire a write-lock
   * Locks are released on commit/rollback 
   * If the requested lock is not available, transaction wait



#### **Two-Phase Locking会使用 (2PL)** -> guarantee serialisability

1. rules:

   * Every transaction must lock an item (read or write) before accessing it
   * Once a lock has been released, no new items can be locked

   

1. Preventing the Lost Update Problem 

![微信图片_20230613222705](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613222705.png)

2.  prevent Uncommitted Dependency

![微信图片_20230613222745](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613222745.png)

3. prevent the Inconsistent Analysis

![微信图片_20230613223037](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613223037.png)

* problems:

  1. Cascading Rollback(roll back after release of lock)

  ![微信图片_20230613223423](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613223423.png)

  2. Deadlock(cross apply for data)

  ![微信图片_20230613223452](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613223452.png)

### Timestamp

1. definition: unique identifier created by DBMS that indicates relative starting time of a transaction. 
2. no locks -> no deadlock(读写时间戳见ppt)

![微信图片_20230613224101](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230613224101.jpg)

### Recovery & Log File

1. Recovery: Process of restoring database to a correct state in the event of a failure. 
2. failure time:
   * between commit and database buffers being flushed to secondary storage: redo (roll-forward)
   * had not committed at failure time: undo (rollback) 
3. Log File: Contains information about all updates to database
4. checkpoint:(redo / undo)

![微信图片_20230614232940](https://github.com/laotianye01/laotianye01.github.io/blob/main/images/2024-02-08-database/微信图片_20230614232940.jpg)



# Distributed DBMSs

### <font color=red>basic knowledge</font>!!

* 2-tier / 3-tier client / sever architecture: 
  * computer(user interface)
  * (application sever: business logic + data processing)
  * database server

* Distributed Database: logical interrelated collection of shared data physically spread over a computer network
* Distributed DBMS: software system permits the management of distributed data and make the distribution transparent to user(distributed processing: centralize database)
* Homogeneous DDBMS: all sites: same database; Heterogeneous DDBMS: sites may run different project
* key issue in design: fragmentation, allocation, replication(copy of fragmentation may store in different sites)
* transparency: 
  * distribution transparency: like single logic entity
  * naming transparency: unique name(use prefix)
  * transaction transparency: maintain transection's integrity and consistency
  * perform transparency: perform as a centralized one

* xml: markup specification language
* DTD: define the valid syntax of XML
* XML schema(XSD): definition of a XML structure
* difference between relation / XML:
  * table / tree
  * fixed / self-describing
  * SQL / ~~
  * non-ordered / ordered
  * mature / add-on
* data mining: extracting valid, unknown, comprehensible, actionable information from database
* 4 operation:
  * predictive modelling
  * database segmentation
  * link analysis
  * deviation detection
* NoSQL: not only SQL(can't be frequently update)
  * map-reduce framework
  * key-value store
  * document store
  * graph database system
* Data Warehouse: providing data for mining(ensure data quality & consistency)









## 1.learning outline:

1. understand **architecture**/be able to explain **two & three tier client/server architecture** 
2. understand/be able to explain **concept of distributed database**
3. understand **function** and **architecture** of DDBMS
4. understand/be able to explain **key issue** in **distribute database design**
5. understand **importance and different types of fragmentation**
6. understand different types of **transparency**
7. understand **advantage & disadvantage of distribute database**

## 2.database architecture & two/three client/server architecture:

1. database architecture
   * definition: Database application programmes and the database DO NOT NEED to reside on the same computer
2. Two-Tier
   * definition: **computer(client)** connected over wired/wireless local area network(LAN) ,database itself is store in **database server**
3. Multi-tier(three)
   * definition: **user interface layer** on computer(client), the business layer and data processing layer(application server), **DBMS** store the data required by middle layer(database server)

## 3.Distributed Database & Distributed DBMS

1. Distributed Database definition: **logical interrelated collection of shared data**(plus description of data), physically spread over a computer.

2. Distributed DBMS definition: **software system** that permit the management of the distributed database and  make distribution  transparent to user.

3. distributed  processing(centralize database)/distributed process(split logical database into fragment and distributed over network) 

4. category: Homogeneous/Heterogenous DDBMS

   * Homogeneous: All sites use same DBMS product.  easier to design and manage. provides incremental growth and allows increased performance
   * Heterogeneous: Sites may run different DBMS products, site implement own database(integration happens later),translation allow for(different hardware,DBMS product)

5. function of DDBMS:(**function of DBMS & can be extension**)

   * at least **function of DBMS**
   * Extended communication services.
   * Extended Data Dictionary.
   * Distributed query processing.
   * Extended concurrency control.
   * Extended recovery services.

6. Reference Architecture for DDBMS: Due to diversity, **no accepted architecture** equivalent to ANSI/SPARC 3-level architecture

   * A reference architecture consists of(some maybe missing):

     • Set of global external schemas.

     • Global conceptual schema (GCS).

     • Fragmentation schema and allocation schema.

     • Set of schemas for each local DBMS conforming to 3-level ANSI/SPARC.

7. Component Architecture for a DDBMS

   1. **Local DBMS** (LDBMS): standard DBMS, responsible for **controlling the local data** at each site that has a database

   2. **Data Communications** (DC): **software** enabling all sites to communicate with each other.

   3. **Global System Catalogue** (GSC): holds information **specific to the distributed nature**(分布性质) of the system, such as the fragmentation, replication, and allocation schemas (it can be managed as a distributed database).

   4. **Distributed DBMS** (DDBMS): the **controlling unit** of the entire system.

## 4.**key issue** in distribute database design(Fragmentation)

* key issue:
  1. **fragmentation**(logical data unit): Relation may be divided into a number of sub-relations, which are then distributed.
  2. **allocation**: Each fragment is stored at the site with “optimal”(最佳的) distribution.
  3. **replication**: Copy of fragment may be maintained at several sites.

* fragmentation:

  1.  drawback: low performance(obtain data from different chart);harder integrity control(data and dependency are fragmented)

  2. correctness:

     * **Completeness**(cover all data in formal chart)
     * **Reconstruction**(exist a way to reconstruct the chart)
     * **Disjointness**(except primary key: no repeat data)

  3. type of fragment:

     * **Horizontal**(use attribute's content to split the chart: Selection)

       select * from Property-For-Rent where type='House'

     * **Vertical**(use attributes to split chart: Projection)

       select staff-No, position, sex, from Property-For-Rent

     * **Mixed**(using Selection and Projection operations )

## 5.different types of transparency

1. definition: hiding the complexity of DDMS

* **Distribution Transparency**: user ignore: data is fragmented;location of data items;Replication of fragments
* **naming Transparency**: each item in DDB must have unique name, 
  1. solution 1: central name server(disadvantage: loss of local autonomy, low availability...)
  2. solution 2: prefix the object with identifier of the site that created it. ex: S1.BRANCH.F3.C2 (low distribution transparency)
* **Transaction Transparency**: ensure each distribute transaction maintain integrity and consistency(synchronization of global transaction and sub)
* **Performance Transparency**: must perform as if there is a centralized DBMS,Distributed Query Processor (DQP) maps data request into ordered sequence
  * jobs: optimized cost function.(different way of selection result in different time consumption->limit on maximum flow of data,delay on communication...example in PPT DBMs P49)

## 6.advantage & disadvantage of DDBMS

1. advantage:

   • Reflects organizational structure

   • Improved shareability and local autonomy

   • Improved availability

   • Improved reliability

   • Improved performance

   • Economics

   • Modular growth

2. disadvantage:

   • Complexity

   • Cost

   • Security

   • Integrity control more difficult

   • Lack of standards

   • Lack of experience

   • Database design more complex

# XML(brief)

# 1.learning outcome:

1. Understand and be able to **recognise XML syntax**
2. Understand and be able to explain what is **“well-formed”/”valid” XML**
3. Understand and be able to explain the **purpose of DTD**
4. Understand and be able to explain the **purpose of XML schema (XSD)**
5. Be able to explain the differences between **relational model and XML**

## 2.XML syntax

1. definition: **extensible Markup Language**, meta-language (i.e. a language for describing other languages) ->similar to HTML
2. usage: Standard for data representation and exchange(setting file)->don't do anything, so need to be translate to HTML
3. marker: have one root element **< Bookstore >**,all sentence block is declare in **<>content</>** form

## 3.well-formed XML

* basic standard for well-formed:

  • Single root element

  • Matched tags, proper nesting

  • Unique attributes within elements

## 4.purpose of Document Type Definitions (DTDs)

1. usage: **Defines** the **valid syntax** of an XML document. include: **Element** Type Declarations,**Attribute** List Declarations,Element Identity, IDs, IDREFs

## 5.purpose of XML schema (XSD)

1. usage: DTDs has limitations(written in non-XML syntax;no support for namespace...) a **more comprehensive** method of **defining content model** of an XML document

## 6.Relational Model versus XML

![微信图片_20230609160243](C:\Users\HP\Desktop\产品开发与管理复习\picture\微信图片_20230609160243.jpg)



# data mining:



## 1.learning outcome:

1. Understand and be able to explain the **concept of data mining.**
2. Understand and be able to explain **different applications of data mining.**
3. Understand some of the **basic techniques** associated with data mining 
   * operations:
     1. **predictive modelling**, 
     2. **database segmentation**, 
     3. **link analysis**, 
     4. **deviation detection**. 

## 2. concept of data mining

* The process of extracting **valid**, previously **unknown**, **comprehensible**, and **actionable** information from large databases and using it to make crucial **business decisions**.(analyse & find the hiding data/relation)

## 3.applications of data mining

1. Retail / Marketing(Identifying buying patterns of customers,Predicting response to mailing campaigns...)
2. Banking(Identifying loyal customers,Predicting customers likely to change their credit card affiliation)
3. Insurance(Predicting which customers will buy new policies,risk evaluation...)
4. Medicine(Identifying successful medical therapies for different illnesses...)

## 4.Operations

1. associated techniques:![微信图片_20230609161715](C:\Users\HP\Desktop\产品开发与管理复习\picture\微信图片_20230609161715.jpg)

### 1.Predictive Modelling(examples in data mining P12)

1. steps:
   * uses observations to form a model;
   * Uses generalisations of ‘real world’ and ability to fit new data into a general framework. 
2. capability: analyse a database to determine essential characteristics (model) about the data set. 
3. related techniques:
   * classification: 
     1. tree induction 
     2. neural induction
   * value prediction

### 2.Database segmentation

* definition: Uses **unsupervised learning** to discover homogeneous subpopulations in a database to improve the accuracy of the profiles.(cheaper than other operation: less sensitive)

### 3.Link Analysis

1. definition: **Establishing links, called associations**, between the individual 

   **records**, or sets of records, in a database. 

2. Types of link analysis: 
   * associations discovery , 
   * sequential pattern discovery
   * similar time sequence discovery 

### 4.Deviation Detection

1. definition: Identifies outliers, which express deviation from some previously 

   known expectation and norm.

# NoSQL(very brief)

## 1.Learning Outcomes

1. Understand the **motivation for NoSQL**
2. Understand and be able to explain the **concepts of NoSQL**
3. Understand and be able to explain the **application areas of NoSQL**

## 2.motivation for NoSQL

* To tackle the **challenges of Big Data**

## 3.concepts of NoSQL

1. definition: **Not Only SQL or “Not Relational”**
2. features: 
   * advantage: Flexible schema,Quicker/cheaper to set up,Massive scalability
   * disadvantage: No declarative query language --> more programming;Relaxed consistency --> fewer guarantees
   * do not provide ACID properties (ACID = Atomicity, Consistency, Isolation, Durability)
3. reason for it:
   * No ACID constraints
   * Gain performance and scalability

## 4.application areas of NoSQL

1. area

* **MapReduce framework**(No data model, data stored in files)
* **Key-value stores**(Extremely simple interface, efficiency, scalability, fault-tolerance)
* **Document stores**(Like Key-Value Stores except value is document)
* **Graph database systems**(Data model: nodes and edges)

2. reason
   * Semi‐structured or flat files based data stores are best for massive data that is read, possibly frequently, but with minimal updates.
   * There is much less overhead to process data in this format.
   * We also have the flexibility to process data that doesn’t have a completely fixed structure.
3. should **NOT** be used for: frequent updates as well as reads, or that requires high integrity and atomicity (ACID properties) 